<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h1 id="3D数学"><a href="#3D数学" class="headerlink" title="3D数学"></a>3D数学</h1><h2 id="Mathf"><a href="#Mathf" class="headerlink" title="Mathf"></a>Mathf</h2><p><code>Mathf.PI</code>圆周率</p><p><code>Mathf.Abs()</code>绝对值</p><p><code>Mathf.CeilToInt()</code>向上取整（不是4舍5入）</p><p><code>Mathf.FloorToInt()</code>向下取整（不是4舍5入）</p><p><code>Mathf.Clamp(10，11，20)</code>钳形函数（第一个数和后面两个数进行比较，小于后面最小的数取最小数，大于同理，在他们之间则取本身）</p><p><code>Mathf.Max(1,23,4)</code>最大值</p><p><code>Mathf.Min()</code>最小值</p><p><code>Mathf.Pow(2,3);</code>谁的几次方</p><p><code>Mathf.RoundToint()</code>四舍五入</p><p><code>Mathf.Sqrt()</code>平方根</p><p><code>Mathf.IsPowerOfTwo()</code>判断一个数是不是2的n次幂</p><p><code>Mathf.Sign()</code>判断一个数是不是正数（正数返回1负数返回-1）</p><p><code>Mathf.Lerp(start,10,Time.deltaTime)</code>插值运算Lerp</p><h2 id="Mathf之三角函数"><a href="#Mathf之三角函数" class="headerlink" title="Mathf之三角函数"></a>Mathf之三角函数</h2><h3 id="角度和弧度的转换关系"><a href="#角度和弧度的转换关系" class="headerlink" title="角度和弧度的转换关系"></a>角度和弧度的转换关系</h3><p>1rad &#x3D; 57.3° 1° &#x3D; 0.01745rad</p><p><code>Mathf.Rad2Deg</code>弧度转角度</p><p><code>Mathf.Deg2Rad</code>角度转弧度</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p><code>Mathf.Sin()</code>传入的是弧度角</p><p><code>Mathf.Cos()</code></p><h3 id="反三角函数（正弦或余弦对应的弧度）"><a href="#反三角函数（正弦或余弦对应的弧度）" class="headerlink" title="反三角函数（正弦或余弦对应的弧度）"></a>反三角函数（正弦或余弦对应的弧度）</h3><p><code>Mathf.Asin()</code></p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>世界坐标系：顾名思义</p><p>物体坐标系：建模时的坐标系，在unity中可以理解为本地坐标系</p><p>屏幕坐标系：1920：1080从屏幕的坐下角为zero</p><p>视口坐标系：将屏幕坐标系的长宽转换成0~1</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>两点确定一个向量，终点减起点</p><p><code>Vector3(2,3,2).magnitude</code>模长</p><p><code>Vector3(2,3,2)</code>.normalized单位向量</p><h2 id="点乘-Dot"><a href="#点乘-Dot" class="headerlink" title="点乘(Dot)"></a>点乘(Dot)</h2><p>几何意义：可以得到一个向量在自己向量上的投影</p><p>作用：可以用这个规律来实现敌人的大致判断方位</p><p>A(Xa,Ya,Za) B(Xb,Yb,Zb)</p><p>A·B &#x3D; Xa<em>Xb + Ya</em>Yb + Za*Zb（标量）</p><p>点成的结果：&gt;0锐角 &#x3D;0直角 &lt;0钝角</p><p><code>Vecrot3.Dot(transform.forword,targeObject.transform.postion - transform.postion)</code>;</p><p><code>Vector3.Angle();</code>计算两个角之间的夹角</p><h2 id="叉乘-Cross"><a href="#叉乘-Cross" class="headerlink" title="叉乘(Cross)"></a>叉乘(Cross)</h2><p>几何意义：法向量</p><p>作用：判断敌人的左右</p><p><code>Vector3.Cross();</code></p><h2 id="向量插值运算（Lerp）"><a href="#向量插值运算（Lerp）" class="headerlink" title="向量插值运算（Lerp）"></a>向量插值运算（Lerp）</h2><p><code>Vector3.Lerp(StartPos,target,time);</code></p><h2 id="球形插值（Slerp）"><a href="#球形插值（Slerp）" class="headerlink" title="球形插值（Slerp）"></a>球形插值（Slerp）</h2><p><code>Vector3.Slerp(StartPos,target,time);</code></p><h2 id="欧拉角（Rotation"><a href="#欧拉角（Rotation" class="headerlink" title="欧拉角（Rotation)"></a>欧拉角（Rotation)</h2><p>X-Y-Z</p><p>为什么有万向锁死：欧拉角描述相对于初始状态的变换，只和最终状态有关，与过程无关。</p><p>可以简单的认为中间的y轴旋转90°后两个轴重合，失去一个自由度</p><h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><p><code>Quaternion.AngleAxis()</code>旋转角度轴（20，Vector.up）</p><p><code>Quaternion.Slerp()</code>对旋转角度进行插值运算(transform.postion,target.postion,Time.daletime)</p><p><code>Quaternion.LookRotation()</code>将一个向量转换成四元数旋转角度</p><h3 id="四元数-四元数"><a href="#四元数-四元数" class="headerlink" title="四元数 * 四元数"></a>四元数 * 四元数</h3><p>两个四元数相乘得到一个新的四元数，代表两个旋转量的叠加，相当于旋转（相对于自身坐标系）</p><p>例如：transform.postion.rotation *&#x3D; p1（旋转p1角度）</p><h3 id="四元数-向量"><a href="#四元数-向量" class="headerlink" title="四元数 * 向量"></a>四元数 * 向量</h3><p>将向量旋转，返回的是旋转的向量</p><h2 id="延迟函数"><a href="#延迟函数" class="headerlink" title="延迟函数"></a>延迟函数</h2><p><code>Invoke(&quot;function&quot;,2);</code></p><p><code>InvokeRepeating(&quot;function&quot;,2,1);</code>两秒后，每隔一秒执行一次</p><p><code>CancelInvoke();</code>取消延迟函数</p><h2 id="范围检测"><a href="#范围检测" class="headerlink" title="范围检测"></a>范围检测</h2><p>作用：一瞬间碰撞检测，没有真的生成碰撞体，攻击检测</p><p>Physics.OverlapBox(Vector3.zero,Vector3.one,Quaternion.AngleAxis(45,Vector3.up),1&lt;&lt;LayerMask.NameToLayer(“UI”)) </p><p>参数1：检测位置</p><p>参数2：检测的大小</p><p>参数3：检测旋转</p><p>参数4：检测的层级</p><p>知识点（层级左移）：在unity中的层级一共有0 - 31层对应的int类型的32位，一一对应</p><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h2><p>RaycastHit2D.Raycast(Vector2 origin, Vector2 direction, float distance, int layerMask)</p><p>参数1：起始位置</p><p>参数2：检测方向</p><p>参数3：检测距离</p><p>参数4：检测的层级</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h1><h2 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h2><ul><li><code>gameObject.name</code> 名字</li><li><code>gameObject.activeSelf</code> 激活状态</li><li><code>gameObject.isStatic</code> 静态状态</li><li><code>gameObject.layer</code> 层级</li><li><code>gameObject.tag</code> 标签</li><li><code>gameObject.transform.position</code> 位置</li></ul><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li><code>GameObject.CreatePrimitive(PrimitiveType.Cube);</code> &#x2F;&#x2F; 创建一个Cube类型的物体，返回一个GameObject。</li></ul><h3 id="查找单个对象"><a href="#查找单个对象" class="headerlink" title="查找单个对象"></a>查找单个对象</h3><p>无法找到失活的对象，多个满足条件的对象时返回不确定的对象，所以应确保唯一性。</p><ul><li><code>GameObject.Find(&quot;&quot;);</code> &#x2F;&#x2F; 根据名字查找（效率低）</li><li><code>GameObject.FindWithTag(&quot;&quot;);</code> &#x2F;&#x2F; 根据tag查找</li></ul><h3 id="查找多个对象"><a href="#查找多个对象" class="headerlink" title="查找多个对象"></a>查找多个对象</h3><ul><li><code>GameObject[] objs = GameObject.FindGameObjectsWithTag(&quot;Player&quot;);</code></li><li><code>findtag mytag = GameObject.FindObjectOfType&lt;findtag&gt;();</code> &#x2F;&#x2F; 效率较低，要遍历所有对象及其脚本</li></ul><h3 id="实例化对象（克隆）"><a href="#实例化对象（克隆）" class="headerlink" title="实例化对象（克隆）"></a>实例化对象（克隆）</h3><ul><li><code>Instantiate(obj);</code></li></ul><h3 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h3><ul><li><code>GameObject.Destroy(obj, 5);</code> &#x2F;&#x2F; 延迟几秒删除</li><li><code>Destroy(this);</code> &#x2F;&#x2F; 删除脚本</li><li><code>DontDestroyOnLoad(gameObject);</code> &#x2F;&#x2F; 过场景不被删除</li></ul><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="创建一个空物体"><a href="#创建一个空物体" class="headerlink" title="创建一个空物体"></a>创建一个空物体</h3><ul><li><code>GameObject obj = new GameObject();</code></li><li><code>GameObject obj1 = new GameObject(&quot;我新创建物体的名字&quot;);</code> &#x2F;&#x2F; 创建一个名字为”我新创建物体的名字”的物体</li><li><code>GameObject obj2 = new GameObject(&quot;我新创建物体的名字2&quot;, typeof(findtag));</code> &#x2F;&#x2F; 创建一个物体并附加一个脚本</li></ul><h3 id="为对象添加脚本"><a href="#为对象添加脚本" class="headerlink" title="为对象添加脚本"></a>为对象添加脚本</h3><ul><li><code>gameObject.AddComponent&lt;BoxCollider2D&gt;();</code></li></ul><h3 id="标签比较"><a href="#标签比较" class="headerlink" title="标签比较"></a>标签比较</h3><ul><li><code>gameObject.CompareTag(&quot;Player&quot;);</code></li><li><code>gameObject.tag == &quot;Player&quot;;</code></li></ul><h3 id="设置失活"><a href="#设置失活" class="headerlink" title="设置失活"></a>设置失活</h3><ul><li><code>gameObject.SetActive(false);</code></li></ul><h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><h2 id="时间缩放"><a href="#时间缩放" class="headerlink" title="时间缩放"></a>时间缩放</h2><ul><li><code>Time.timeScale = 0;</code> &#x2F;&#x2F; 时间流速停止</li><li><code>Time.timeScale = 1;</code> &#x2F;&#x2F; 时间流速正常</li><li><code>Time.timeScale = 2;</code> &#x2F;&#x2F; 时间流速倍速</li></ul><h2 id="帧间隔时间"><a href="#帧间隔时间" class="headerlink" title="帧间隔时间"></a>帧间隔时间</h2><ul><li><code>Time.deltaTime</code> &#x2F;&#x2F; 受scale影响</li><li><code>Time.unscaledDeltaTime</code> &#x2F;&#x2F; 不受scale影响</li></ul><h2 id="游戏开始到现在的时间"><a href="#游戏开始到现在的时间" class="headerlink" title="游戏开始到现在的时间"></a>游戏开始到现在的时间</h2><ul><li><code>Time.time</code> &#x2F;&#x2F; 受scale影响</li><li><code>Time.unscaledTime</code> &#x2F;&#x2F; 不受scale影响</li></ul><h2 id="帧数（游戏跑了多少帧）"><a href="#帧数（游戏跑了多少帧）" class="headerlink" title="帧数（游戏跑了多少帧）"></a>帧数（游戏跑了多少帧）</h2><ul><li><code>Time.frameCount</code></li></ul><h1 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h1><h2 id="位置和位移"><a href="#位置和位移" class="headerlink" title="位置和位移"></a>位置和位移</h2><h3 id="创建一个向量"><a href="#创建一个向量" class="headerlink" title="创建一个向量"></a>创建一个向量</h3><ul><li><code>Vector3 v1 = new Vector3(1, 2, 3);</code></li></ul><h3 id="常用的方向向量"><a href="#常用的方向向量" class="headerlink" title="常用的方向向量"></a>常用的方向向量</h3><ul><li><code>Vector3.zero</code> &#x2F;&#x2F; (0, 0, 0)</li><li><code>Vector3.right</code> &#x2F;&#x2F; (1, 0, 0)</li><li><code>Vector3.left</code> &#x2F;&#x2F; (-1, 0, 0)</li><li><code>Vector3.forward</code> &#x2F;&#x2F; (0, 0, 1)</li><li><code>Vector3.back</code> &#x2F;&#x2F; (0, 0, -1)</li><li><code>Vector3.up</code> &#x2F;&#x2F; (0, 1, 0)</li><li><code>Vector3.down</code> &#x2F;&#x2F; (0, -1, 0)</li></ul><h3 id="计算两个点之间的距离"><a href="#计算两个点之间的距离" class="headerlink" title="计算两个点之间的距离"></a>计算两个点之间的距离</h3><ul><li><code>Vector3.Distance(v1, v2);</code></li></ul><h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><ul><li><code>transform.position</code> &#x2F;&#x2F; 世界坐标系</li><li><code>transform.localPosition</code> &#x2F;&#x2F; 本地坐标系</li><li><code>transform.forward</code> &#x2F;&#x2F; 自身坐标系的面朝向</li></ul><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><ul><li><code>transform.Translate(Vector3.forward * 1 * Time.deltaTime, Space.World);</code></li></ul><h2 id="角度和旋转"><a href="#角度和旋转" class="headerlink" title="角度和旋转"></a>角度和旋转</h2><ul><li><code>transform.eulerAngles</code> &#x2F;&#x2F; 世界坐标角度</li><li><code>transform.localEulerAngles</code> &#x2F;&#x2F; 自身坐标系角度</li><li><code>transform.Rotate(new Vector3(0, 10, 0), Space.World);</code> &#x2F;&#x2F; 自转</li><li><code>transform.Rotate(Vector3.zero, 10 * Time.deltaTime, Space.World);</code> &#x2F;&#x2F; 绕轴转</li><li><code>transform.RotateAround(Vector3.zero, Vector3.up, 10 * Time.deltaTime);</code> &#x2F;&#x2F; 绕点转</li></ul><h2 id="缩放看向"><a href="#缩放看向" class="headerlink" title="缩放看向"></a>缩放看向</h2><ul><li><code>transform.lossyScale</code> &#x2F;&#x2F; 相对世界缩放（只读）</li><li><code>transform.localScale</code> &#x2F;&#x2F; 相对父物体缩放</li><li><code>transform.LookAt(Vector3.zero);</code> &#x2F;&#x2F; 看向一个点（世界坐标系）</li><li><code>transform.LookAt(Transform);</code> &#x2F;&#x2F; 看向一个点</li></ul><h2 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h2><h3 id="设置父对象"><a href="#设置父对象" class="headerlink" title="设置父对象"></a>设置父对象</h3><ul><li><code>transform.parent = null;</code> &#x2F;&#x2F; 没有父物体</li><li><code>transform.SetParent(GameObject.transform, false);</code> &#x2F;&#x2F; 设置父物体，第二个参数为是否保留世界坐标</li></ul><h3 id="设置子对象为空"><a href="#设置子对象为空" class="headerlink" title="设置子对象为空"></a>设置子对象为空</h3><ul><li><code>transform.DetachChildren();</code> &#x2F;&#x2F; 断绝所有子对象</li></ul><h3 id="获取子对象"><a href="#获取子对象" class="headerlink" title="获取子对象"></a>获取子对象</h3><ul><li><code>transform.Find(&quot;&quot;);</code> &#x2F;&#x2F; 查找所有儿子，能找到失活的对象，找不到孙子</li><li><code>transform.childCount</code> &#x2F;&#x2F; 子对象数量，包括失活对象，找不到孙子</li><li><code>transform.GetChild(i);</code> &#x2F;&#x2F; 获取对应的儿子</li></ul><h3 id="儿子的操作"><a href="#儿子的操作" class="headerlink" title="儿子的操作"></a>儿子的操作</h3><ul><li><code>public Transform son;</code></li><li><code>son.IsChildOf(transform);</code> &#x2F;&#x2F; 判断是否是指定对象的子物体</li><li><code>son.GetSiblingIndex();</code> &#x2F;&#x2F; 获取儿子编号</li><li><code>son.SetAsFirstSibling();</code> &#x2F;&#x2F; 设置为第一个儿子</li><li><code>son.SetAsLastSibling();</code> &#x2F;&#x2F; 设置为最后一个儿子</li><li><code>son.SetSiblingIndex();</code> &#x2F;&#x2F; 设置为指定序列的儿子</li></ul><h2 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h2><h3 id="世界坐标转本地坐标"><a href="#世界坐标转本地坐标" class="headerlink" title="世界坐标转本地坐标"></a>世界坐标转本地坐标</h3><h4 id="点的转换（受缩放影响）"><a href="#点的转换（受缩放影响）" class="headerlink" title="点的转换（受缩放影响）"></a>点的转换（受缩放影响）</h4><ul><li><code>transform.InverseTransformPoint(Vector3.forward);</code></li></ul><h4 id="向量转换"><a href="#向量转换" class="headerlink" title="向量转换"></a>向量转换</h4><ul><li><code>transform.InverseTransformDirection(Vector3.forward);</code> &#x2F;&#x2F; 不受缩放影响</li><li><code>transform.InverseTransformVector(Vector3.forward);</code> &#x2F;&#x2F; 受缩放影响</li></ul><h3 id="本地坐标转世界坐标"><a href="#本地坐标转世界坐标" class="headerlink" title="本地坐标转世界坐标"></a>本地坐标转世界坐标</h3><h4 id="点的转换"><a href="#点的转换" class="headerlink" title="点的转换"></a>点的转换</h4><ul><li><code>transform.TransformPoint(Vector3.forward);</code> &#x2F;&#x2F; 受缩放影响</li></ul><h4 id="方向转换"><a href="#方向转换" class="headerlink" title="方向转换"></a>方向转换</h4><ul><li><code>transform.TransformDirection(Vector3.forward);</code> &#x2F;&#x2F; 不受缩放影响</li><li><code>transform.TransformVector(Vector3.forward);</code> &#x2F;&#x2F; 受缩放影响</li></ul><h1 id="Input和Screen"><a href="#Input和Screen" class="headerlink" title="Input和Screen"></a>Input和Screen</h1><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><h3 id="检测鼠标输入"><a href="#检测鼠标输入" class="headerlink" title="检测鼠标输入"></a>检测鼠标输入</h3><ul><li><code>Input.mousePosition</code></li><li><code>Input.GetMouseButtonDown(0);</code> &#x2F;&#x2F; 按下左键</li><li><code>Input.GetMouseButtonUp(0);</code> &#x2F;&#x2F; 弹起左键</li><li><code>Input.GetMouseButton(0);</code> &#x2F;&#x2F; 长按左键</li><li><code>Input.mouseScrollDelta</code> &#x2F;&#x2F; 滚轮滚动（-1下、0没滚、1上）</li></ul><h3 id="检测键盘输入"><a href="#检测键盘输入" class="headerlink" title="检测键盘输入"></a>检测键盘输入</h3><ul><li><code>Input.GetKeyDown(KeyCode.W);</code> &#x2F;&#x2F; 按下</li><li><code>Input.GetKeyDown(&quot;q&quot;);</code> &#x2F;&#x2F; 按下，必须小写</li><li><code>Input.GetKeyUp(KeyCode.W);</code> &#x2F;&#x2F; 弹起</li><li><code>Input.GetKey(KeyCode.W);</code> &#x2F;&#x2F; 长按</li></ul><h3 id="检测默认轴输入"><a href="#检测默认轴输入" class="headerlink" title="检测默认轴输入"></a>检测默认轴输入</h3><ul><li><code>Input.GetAxis(&quot;Horizontal&quot;);</code></li><li><code>Input.GetAxis(&quot;Vertical&quot;);</code></li><li><code>Input.GetAxis(&quot;Mouse X&quot;);</code></li><li><code>Input.GetAxis(&quot;Mouse Y&quot;);</code></li></ul><blockquote><p>注意：<code>GetAxisRaw</code>没有渐变-1和1，<code>GetAxis</code>有渐变-1到1</p></blockquote><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><code>Input.anyKeyDown</code>任意键按下</p><p><code>Input.inputString</code>键盘输入</p><h1 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h1><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><h3 id="屏幕分辨率"><a href="#屏幕分辨率" class="headerlink" title="屏幕分辨率"></a>屏幕分辨率</h3><p><code>Screen.currentResolution.width``Screen.currentResolution.height</code></p><h3 id="窗口分辨率"><a href="#窗口分辨率" class="headerlink" title="窗口分辨率"></a>窗口分辨率</h3><p><code>Screen.width</code></p><h3 id="息屏休眠"><a href="#息屏休眠" class="headerlink" title="息屏休眠"></a>息屏休眠</h3><p><code>Screen.sleepTimeout = SleepTimeout.NeverSleep;</code></p><h2 id="场景（api）"><a href="#场景（api）" class="headerlink" title="场景（api）"></a>场景（api）</h2><p><code>SceneManager.LoadScene(&quot;场景的名字&quot;);</code>场景切换</p><p><code>SceneManager.GetActiveScene</code>;获得激活的场景<br><code>Application.Quit();</code>退出游戏</p><h1 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h1><p><code>Camera.main</code>获取主摄像机</p><p><code>Camera.allCameraCount</code>获取摄像机的数量</p><p><code>Camera.main.WorldToScreenPoint()</code>世界坐标转屏幕坐标（x,y是根据屏幕坐标系物体的位置，z是物体距离摄像机的距离）</p><p><code>Camera.main.ScreenToWorldPoint()</code>屏幕坐标转世界坐标</p><h1 id="物理系统之碰撞检测"><a href="#物理系统之碰撞检测" class="headerlink" title="物理系统之碰撞检测"></a>物理系统之碰撞检测</h1><p><code>private void OnCollisionEnter(Collision collision)&#123;&#125;</code>接触时执行<br><code>private void OnCollisionExit(Collision collision)&#123;&#125;</code>离开时执行<br><code>private void OnCollisionStay(Collision collision)&#123;&#125;</code>持续碰撞执行<br><code>private void OnTriggerEnter(Collider other)&#123;&#125;</code>同理</p><h2 id="添加力"><a href="#添加力" class="headerlink" title="添加力"></a>添加力</h2><p><code>private RigidBody rb;</code><br><code>rb.AddForce();</code>世界坐标<br><code>rb.AddRelativeForce();</code>相对坐标系</p><h2 id="扭矩力-旋转"><a href="#扭矩力-旋转" class="headerlink" title="扭矩力(旋转)"></a>扭矩力(旋转)</h2><p><code>rb.AddTorque();</code>世界坐标<br><code>rb.AddRelativeTorque();</code>本地坐标</p><h2 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h2><p><code>rb.velocity();</code>世界坐标</p><h2 id="爆炸力"><a href="#爆炸力" class="headerlink" title="爆炸力"></a>爆炸力</h2><p><code>rb.AddExplosionForce(100,Vector.zero,10);</code>1.力的大小2.力的位置3.力的半径</p><h2 id="刚体的休眠-unity为了节约性能"><a href="#刚体的休眠-unity为了节约性能" class="headerlink" title="刚体的休眠(unity为了节约性能)"></a>刚体的休眠(unity为了节约性能)</h2><p><code>rb.IsSleeping();</code><br><code>rb.WakeUp();</code></p><h1 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h1><h2 id="代码控制音效"><a href="#代码控制音效" class="headerlink" title="代码控制音效"></a>代码控制音效</h2><p><code>public AudioSource audioSource;</code><br><code>audioSource.Play();</code>播放音乐<br><code>audioSource.Stop();</code>暂停播放<br><code>audioSource.Pause();</code>暂停<br><code>audioSource.isPlaying</code>是否正在播放</p><h1 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h1><h2 id="鼠标的相关设置"><a href="#鼠标的相关设置" class="headerlink" title="鼠标的相关设置"></a>鼠标的相关设置</h2><p><code>Cursor.visible = false;</code>隐藏鼠标<br><code>Cursor.lockState = CursorLockMode.Confined;</code>锁定鼠标(None不锁定Locked锁定在屏幕中心+隐藏Confined限制在窗口范围内)<br><code>Cursor.SetCursor(tex,Vector2.zero,CursorMode.Auto);</code>设置鼠标的图片</p><p>参数一：光标的图片 参数二：偏移位置 参数三：光标模式</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p><code>Random.range(0,100);</code>左开右闭<br><code>Random.range(0.2f,2.3f);</code>左开右开</p><h2 id="Unity的自带委托"><a href="#Unity的自带委托" class="headerlink" title="Unity的自带委托"></a>Unity的自带委托</h2><p>Learning不会思密达</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
