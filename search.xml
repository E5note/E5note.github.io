<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>类与对象（下）</title>
      <link href="/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2025/04/03/04%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-再谈构造函数"><a href="#1-再谈构造函数" class="headerlink" title="1. 再谈构造函数"></a>1. 再谈构造函数</h2><p>在面向对象编程中，<strong>构造函数</strong> 是一种特殊的成员函数，它在对象创建时自动调用，负责初始化对象的成员变量（创建对象时赋初值），确保对象在创建时有一个有效的状态。接下来，我们将详细讲解关于构造函数的几个重要概念。</p><h3 id="1-1-构造函数体赋值"><a href="#1-1-构造函数体赋值" class="headerlink" title="1.1 构造函数体赋值"></a>1.1 构造函数体赋值</h3><p>当我们创建一个对象时，构造函数会被自动调用，用来给对象的各个成员变量提供一个初始值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;  <span class="comment">// 这里是构造函数体中的赋值操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的作用是将 <code>a</code> 赋值为 10。然而，这里要注意，<strong>构造函数体中的赋值操作和初始化是有区别的</strong>。构造函数体中对成员变量的赋值只能算是给成员变量“赋初值”，而不是“初始化”。因为初始化是指给成员变量设置一个初始值，而且初始化只能发生一次，而赋值操作可以发生多次。</p><p>再例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x; <span class="comment">// 赋值操作：_x 在此之前已经默认初始化（如果有的话），然后被赋值为 x。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">上述代码中，`_x = x;`是赋值，而非初始化，因为初始化只能通过构造函数外部的初始化列表来完成。</span><br><span class="line"></span><br><span class="line">在构造函数体中对成员变量的赋值操作，实际上是先通过默认初始化（如果有的话），然后通过赋值操作覆盖初始值。这与初始化列表直接初始化成员变量有本质区别。</span><br></pre></td></tr></table></figure><p>换句话说，<strong>初始化只能在构造函数中通过初始化列表来进行一次，而构造函数体中的赋值可以反复进行</strong>。</p><p>所以，<strong>赋值与初始化的区别</strong> 在于：</p><ul><li><strong>初始化</strong>：是在对象创建时为成员变量设置初始值的过程，每个成员变量只能被初始化一次，通常在构造函数的初始化列表中进行（只能进行一次）。</li><li><strong>赋值</strong>：是在对象创建后对成员变量进行值的修改，可以发生多次，可以在构造函数体中，也可以在对象的生命周期中的任何时候进行（可以重复进行）。</li></ul><hr><h3 id="1-2-初始化列表"><a href="#1-2-初始化列表" class="headerlink" title="1.2 初始化列表"></a>1.2 初始化列表</h3><p>初始化列表是构造函数中的一种写法（直接初始化类的成员变量的一种方式），允许我们在构造函数调用之前就给成员变量提供初始值。语法是在构造函数的括号后加冒号和成员变量列表，其基本格式是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这里的:`<span class="built_in">a</span>(<span class="number">10</span>)`就是初始化列表，它会在构造函数体执行之前初始化成员变量`a`为<span class="number">10</span>。</span><br></pre></td></tr></table></figure><p>再或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span> _val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">        : _x(x), </span><br><span class="line">          _y(<span class="number">0</span>), </span><br><span class="line">          _val(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125; <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>每个成员变量在初始化列表中只能出现一次。初始化列表的目的是对成员进行一次初始化。</li><li>对于某些特殊类型的成员变量，必须使用初始化列表来进行初始化。例如：<ul><li><strong>引用成员变量</strong>：引用一旦初始化就不可更改，只能在初始化列表中赋值。</li><li><strong>const 成员变量</strong>：常量变量（const 变量）在对象创建时必须初始化，且不可更改；必须在声明时初始化，不能通过构造函数体赋值。</li><li><strong>自定义类型成员</strong>&#x2F;<strong>没有默认构造函数的自定义类型</strong>：自定义类型变量如果没有默认构造函数，只能通过初始化列表初始化。</li></ul></li><li>尽量使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</li><li><strong>初始化列表的顺序</strong>：初始化列表中的成员变量的初始化顺序 <strong>和它们在类中声明的顺序一致</strong>，而不是按照初始化列表中出现的顺序（编译器会按照成员变量在类中声明的顺序进行内存布局，因此初始化顺序也必须与之匹配）。</li></ol><p><strong>推荐使用初始化列表的原因</strong>： 对于自定义类型，编译器会自动调用其构造函数完成初始化，不使用初始化列表而采用先默认构造再赋值可能导致性能浪费。</p><p><strong>类的成员变量初始化顺序</strong> 取决于 <strong>成员变量的声明顺序</strong>，而不是初始化列表的顺序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 此处先声明 a, 再声明 b</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">b</span>(<span class="number">20</span>), <span class="built_in">a</span>(x) <span class="comment">// 初始化列表：b 在 a 之前初始化（就会导致一些奇怪的错误：未定义行为（UB））</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// b 在 a 之后声明，所以 a 会先被初始化，b 才会初始化！</span></span><br><span class="line"><span class="comment">// 如果 b 的初始化依赖 a，就会导致意外的错误或 UB！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 输出：a = 10, b = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="1-3-explicit-关键字"><a href="#1-3-explicit-关键字" class="headerlink" title="1.3 explicit 关键字"></a>1.3 explicit 关键字</h3><p>如果构造函数接收单一参数，它可能会被编译器用于隐式类型转换。而 <code>explicit</code> 关键字则用来标记构造函数，防止它参与隐式类型转换。 隐式类型转换可能导致临时对象的创建和销毁，增加不必要的性能开销，或者在代码中引入难以察觉的错误。</p><p>在 C++中，构造函数不仅可以用来构造和初始化对象，还可以在特定条件下用作类型转换的“隐式转换构造函数”。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;MyClass&#x27; requested</span></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 编译器会用构造函数将10转换为MyClass对象</span></span><br><span class="line"></span><br><span class="line">在上述代码中，`<span class="built_in">MyClass</span>(<span class="type">int</span> x)`构造函数是一个单参构造函数，可以将`<span class="type">int</span>`类型的<span class="number">10</span>隐式转换为`MyClass`类型的对象。</span><br><span class="line">为防止这种类型转换，我们可以在构造函数前加上`<span class="keyword">explicit</span>`关键字，这样就禁止了隐式转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj = <span class="number">10</span>;  <span class="comment">// 错误：不能隐式转换</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) &#123;&#125; <span class="comment">// 单参构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 隐式调用构造函数</span></span><br><span class="line"></span><br><span class="line">**<span class="keyword">explicit</span>的作用**： 使用`<span class="keyword">explicit</span>`关键字禁止隐式类型转换：</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A obj = <span class="number">10</span>; <span class="comment">// 错误，禁止隐式转换</span></span><br><span class="line"><span class="function">A <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExplicitClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyExplicitClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1 = <span class="number">10</span>;  <span class="comment">// 隐式类型转换</span></span><br><span class="line">    MyExplicitClass obj2 = <span class="number">10</span>;  <span class="comment">// 错误：禁止隐式类型转换</span></span><br><span class="line">    <span class="function">MyExplicitClass <span class="title">obj3</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 显式类型转换</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj1 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;obj2 created successfully.&quot; &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;obj3 created successfully.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>explicit</code> 关键字后，只有明确调用构造函数时才能进行类型转换，不能再进行隐式转换。所以，构造函数不仅仅负责创建对象，它还通过初始化列表给对象成员变量赋初值。通过 <code>explicit</code> 关键字，我们可以禁止单参构造函数的隐式类型转换，确保代码的类型安全。</p><hr><h2 id="2-static-成员"><a href="#2-static-成员" class="headerlink" title="2. static 成员"></a>2. static 成员</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>在 C++中，类成员可以被声明为 <code>static</code>，这样的成员称为 <strong>静态成员</strong>。静态成员包括静态成员变量和静态成员函数。</p><ul><li><strong>静态成员变量</strong>：使用 <code>static</code> 修饰的类成员变量，所有对象共享这个变量，不属于某个特定的对象。静态成员变量必须在类外进行初始化（被修饰的变量属于类本身，而不是某个对象）。</li><li><strong>静态成员函数</strong>：使用 <code>static</code> 修饰的成员函数，它是属于类的，而不是类的某个对象（修饰的函数属于类本身，可以直接通过类名调用）。</li></ul><h4 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h4><ol><li><p><strong>静态成员的共享性</strong>： 静态成员变量为所有对象共享，修改其中一个对象的静态成员变量值，会影响其他对象。</p><ul><li>静态成员变量和静态成员函数是属于类本身的，而不是类的某个特定对象。</li><li>所有类对象共享静态成员，这意味着静态成员的值对所有对象是相同的。</li><li>静态成员并不存储在每个对象中，而是存放在一个全局的静态区。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Increment</span><span class="params">()</span> </span>&#123; _count++; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _count; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">0</span>;<span class="comment">//  静态变量必须在类外定义/初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">Increment</span>();</span><br><span class="line">    cout &lt;&lt; A::<span class="built_in">GetCount</span>() &lt;&lt; endl; <span class="comment">// 输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>静态成员变量的初始化</strong>：</p><ul><li><p>静态成员变量在类外进行定义和初始化，而在类内部仅声明。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>;  <span class="comment">// 静态成员变量初始化</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问静态成员</strong>：</p><ul><li>可以通过类名直接访问静态成员：<code>类名::静态成员</code>。</li><li>也可以通过对象访问静态成员：<code>对象.静态成员</code>。但是，通常推荐通过类名来访问，保持代码的清晰和一致性。</li></ul></li><li><p><strong>静态成员函数没有 <code>this</code> 指针</strong>：</p><ul><li>静态成员函数与类的对象无关，静态成员函数属于类本身，而不是某个对象，因此它没有隐藏的 <code>this</code> 指针。</li><li>由于没有 <code>this</code> 指针，静态成员函数无法访问类的非静态成员变量或非静态成员函数（只能访问静态变量，不能访问非静态成员）。</li><li>非静态成员属于对象，而静态成员函数与对象无关，因此无法通过 <code>this</code> 指针访问非静态成员。</li></ul></li><li><p><strong>访问权限</strong>：</p><ul><li>静态成员仍然受类的访问控制（<code>public</code>、<code>protected</code>、<code>private</code>）的限制。</li></ul></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>假设我们要实现一个类，统计类的对象创建次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量，属于类本身</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        count++; <span class="comment">// 每创建一个对象，静态变量 count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count; <span class="comment">// 静态成员函数，返回静态变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj1, obj2, obj3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建的对象数：&quot;</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; endl; <span class="comment">// 输出：创建的对象数：3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员函数和非静态成员函数的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static 函数，staticVar =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;非静态 var =&quot; &lt;&lt; nonStaticVar &lt;&lt; endl;  // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非静态函数，nonStaticVar =&quot;</span> &lt;&lt; nonStaticVar &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;静态 var =&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticFunction</span>();  <span class="comment">// 静态函数调用</span></span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 非静态函数调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h3><h4 id="Q1：静态成员函数可以调用非静态成员函数吗？"><a href="#Q1：静态成员函数可以调用非静态成员函数吗？" class="headerlink" title="Q1：静态成员函数可以调用非静态成员函数吗？"></a>Q1：静态成员函数可以调用非静态成员函数吗？</h4><p><strong>不可以</strong>。静态成员函数没有 <code>this</code> 指针，它与对象无关。因此，它无法访问类的非静态成员变量和非静态成员函数。如果静态成员函数试图访问非静态成员函数或成员变量，会导致编译错误。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个非静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 不能访问非静态成员函数</span></span><br><span class="line">          <span class="comment">// nonStaticFunction();  // 错误：静态成员函数不能访问非静态成员函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="Q2-非静态成员函数可以调用类的静态成员函数吗？"><a href="#Q2-非静态成员函数可以调用类的静态成员函数吗？" class="headerlink" title="Q2: 非静态成员函数可以调用类的静态成员函数吗？"></a>Q2: 非静态成员函数可以调用类的静态成员函数吗？</h4><p><strong>可以</strong>。非静态成员函数属于某个对象，可以访问类的静态成员变量和静态成员函数。非静态成员函数是通过对象的 <code>this</code> 指针来访问类的成员的，所以它可以直接访问静态成员。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">   <span class="type">int</span> nonStaticVar;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nonStaticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">          <span class="comment">// 可以访问静态成员函数</span></span><br><span class="line">          <span class="built_in">staticFunction</span>();</span><br><span class="line">          cout &lt;&lt; <span class="string">&quot;静态变量：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;这是一个静态函数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="type">int</span> MyClass::staticVar = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   obj.<span class="built_in">nonStaticFunction</span>();  <span class="comment">// 调用非静态成员函数，内部可以访问静态成员函数</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是一个静态函数。</span><br><span class="line">&gt;静态变量：10</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="3-友元（Friend）"><a href="#3-友元（Friend）" class="headerlink" title="3. 友元（Friend）"></a>3. 友元（Friend）</h2><p><strong>友元</strong> 是一种打破封装的方式，它允许特定的函数或类访问类的私有成员和保护成员。通常情况下，类的私有成员是只能通过类的成员函数来访问的，但友元提供了一个特例，使得外部函数或类可以访问这些私有成员。尽管友元能提供便利，但它也会增加类之间的耦合度，破坏封装性，因此在设计时应当小心使用。</p><p>友元可以分为两种类型：<strong>友元函数</strong> 和 <strong>友元类</strong>。</p><h3 id="3-1-友元函数"><a href="#3-1-友元函数" class="headerlink" title="3.1 友元函数"></a>3.1 友元函数</h3><ul><li><p><strong>友元函数的定义</strong>： 友元函数是定义在类外的普通函数，但可以访问类的私有成员和保护成员。它并不是类的成员函数，因此没有 <code>this</code> 指针。虽然它是类外的函数，但为了让它可以访问类的私有成员，必须在类内声明为友元函数，使用 <code>friend</code> 关键字。</p></li><li><p><strong>友元函数的特性：</strong></p><ul><li><strong>声明位置</strong>：可以在类定义的任何地方声明，只要在类内部用 <code>friend</code> 关键字。</li><li><strong>访问权限</strong>：友元函数可以访问类的私有和保护成员，但它并不属于类的成员函数。</li><li><strong>不属于类的成员函数</strong>：友元函数的调用和普通函数一样，不通过对象调用，没有 <code>this</code> 指针。</li><li><strong>不能用 <code>const</code> 修饰</strong>：友元函数不能被声明为 <code>const</code>，因为它可能会修改类的私有成员。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 前向声明类 A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> y) : _y(y) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;  <span class="comment">// 友元类：A 类可以访问 B 的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span>;  <span class="comment">// 友元函数声明</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元类 A 可以访问 B 的私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> B&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend class: &quot;</span> &lt;&lt; b._y &lt;&lt; endl;  <span class="comment">// 访问 B 的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Friend function: &quot;</span> &lt;&lt; a._x &lt;&lt; endl;  <span class="comment">// 访问 A 的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Print</span>(a);  <span class="comment">// 调用友元函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Print</span>(b);  <span class="comment">// 调用友元类中的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>友元函数的使用场景</strong>：</p><ul><li>当需要定义一个全局函数，并且需要访问类的私有数据时。</li><li>常用于重载操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>。</li></ul></li></ul><blockquote><h3 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h3><h4 id="Q1：为什么使用友元函数？"><a href="#Q1：为什么使用友元函数？" class="headerlink" title="Q1：为什么使用友元函数？"></a>Q1：为什么使用友元函数？</h4><p>友元函数常用于那些不能作为成员函数实现的操作。例如，重载输入输出运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 时，<code>cout</code> 和 <code>cin</code> 对象是流对象，需要通过全局函数进行操作，而不能作为类的成员函数。</p><h5 id="示例：重载-operator"><a href="#示例：重载-operator" class="headerlink" title="示例：重载 operator&lt;&lt;（输出流）为友元函数"></a>示例：重载 <code>operator&lt;&lt;</code>（输出流）为友元函数</h5><p>假设我们有一个 <code>Box</code> 类，想要重载 <code>&lt;&lt;</code> 运算符来输出 <code>Box</code> 的内容，<code>cout</code> 需要是左操作数，因此 <code>&lt;&lt;</code> 不能作为成员函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> length;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Box</span>(<span class="type">int</span> l) : <span class="built_in">length</span>(l) &#123;&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 声明友元函数</span></span><br><span class="line">       <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box);</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">// 友元函数的定义</span></span><br><span class="line">&gt;ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Box&amp; box)</span><br><span class="line">&gt;&#123;</span><br><span class="line">       os &lt;&lt; <span class="string">&quot;箱长：&quot;</span> &lt;&lt; box.length;</span><br><span class="line">       <span class="keyword">return</span> os;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       <span class="function">Box <span class="title">box</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; box &lt;&lt; endl;  <span class="comment">// 使用重载的operator&lt;&lt;</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;箱长：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>operator&lt;&lt;</code> 是一个友元函数，它被声明为 <code>Box</code> 类的友元，因此它可以访问 <code>Box</code> 类的私有成员 <code>length</code>。</p></blockquote><hr><h3 id="3-2-友元类"><a href="#3-2-友元类" class="headerlink" title="3.2 友元类"></a>3.2 友元类</h3><p><strong>友元类</strong> 是指一个类的所有成员函数都可以成为另一个类的友元函数，因此友元类的所有成员函数都可以访问当前类的私有成员和保护成员。</p><h4 id="友元类的特性："><a href="#友元类的特性：" class="headerlink" title="友元类的特性："></a>友元类的特性：</h4><ul><li><strong>单向关系</strong>：如果类 A 声明类 B 为友元类，那么类 B 的成员函数可以访问类 A 的私有成员，但类 A 的成员函数不能访问类 B 的私有成员。友元关系是单向的（声明友元类 B 后，B 能访问 A，但 A 不能访问 B）。</li><li><strong>不能继承</strong>：友元关系不能被继承，如果类 A 是类 B 的友元类，那么类 B 的派生类不会自动成为类 A 的友元类。</li><li><strong>关系不可传递</strong>：如果 B 是 A 的友元，C 是 B 的友元，那么 C 并不是 A 的友元。</li></ul><h4 id="示例：友元类"><a href="#示例：友元类" class="headerlink" title="示例：友元类"></a>示例：友元类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x) : _x(x) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// 声明B为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AccessA</span><span class="params">(<span class="type">const</span> A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a._x &lt;&lt; endl; <span class="comment">// 访问A的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再假设我们有 <code>Time</code> 类和 <code>Date</code> 类，并希望 <code>Time</code> 类可以访问 <code>Date</code> 类的私有成员。我们可以在 <code>Time</code> 类中声明 <code>Date</code> 为友元类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span>; <span class="comment">// 声明函数，访问 Time 类的私有成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m) : <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Date</span>; <span class="comment">// 声明 Date 类为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::printTime</span><span class="params">(<span class="type">const</span> Time&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; t.hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t.minute &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Time <span class="title">t</span><span class="params">(<span class="number">10</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    Date d;</span><br><span class="line">    d.<span class="built_in">printTime</span>(t); <span class="comment">// 输出：Time: 10:30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Time</code> 类声明了 <code>Date</code> 类为友元类，这样 <code>Date</code> 类的成员函数 <code>printTime</code> 就能够访问 <code>Time</code> 类的私有成员（如 <code>hour</code> 和 <code>minute</code>）。</p><h3 id="SO："><a href="#SO：" class="headerlink" title="SO："></a>SO：</h3><ul><li><strong>友元函数</strong>：允许非成员函数访问类的私有和保护成员。它不是类的成员函数，通常用于操作符重载等场景。</li><li><strong>友元类</strong>：允许一个类的所有成员函数访问另一个类的私有和保护成员。它们的关系是单向的。</li><li><strong>使用场景</strong>：友元可以提高代码的灵活性和可操作性，但过多使用会增加类之间的耦合度，破坏封装，因此要谨慎使用。</li></ul><hr><h2 id="4-内部类（Nested-Class）"><a href="#4-内部类（Nested-Class）" class="headerlink" title="4. 内部类（Nested Class）"></a>4. 内部类（Nested Class）</h2><h3 id="4-1-概念："><a href="#4-1-概念：" class="headerlink" title="4.1 概念："></a>4.1 概念：</h3><p><strong>内部类</strong> 是定义在另一个类内部的类。它是一个独立的类，和外部类没有直接的归属关系，即它并不属于外部类的对象。外部类不能直接访问内部类的成员，反之，内部类可以访问外部类的成员，特别是当外部类的成员是 <code>static</code> 时（内部类天然是外部类的友元，可以访问外部类的私有成员）。</p><p><strong>内部类</strong> 有时也被称为 <strong>嵌套类</strong>，通常用于将一个类作为一个辅助工具类嵌套在另一个类中，通常与外部类的功能紧密相关。</p><p><strong>例如：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">ShowCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; _count &lt;&lt; endl; <span class="comment">// 直接访问静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::_count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::B b;</span><br><span class="line">    b.<span class="built_in">ShowCount</span>(); <span class="comment">// 输出10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><ol><li><strong>独立性</strong>：内部类是一个完全独立的类，它不属于外部类的对象。因此，外部类不能通过自身的对象直接访问内部类的成员。</li><li><strong>友元关系</strong>：虽然外部类不能直接访问内部类的成员，但内部类可以通过外部类的对象访问外部类的所有成员（包括私有成员）。从这个角度来看，内部类可以看作外部类的友元类（<strong>内部类天然具有可以访问外部类的私有成员这种访问权限，而不是因为它是友元类</strong>）。</li></ol><h3 id="4-2-内部类的特性"><a href="#4-2-内部类的特性" class="headerlink" title="4.2 内部类的特性"></a>4.2 内部类的特性</h3><ol><li><strong>访问权限</strong>：<ul><li>内部类可以定义在外部类的 <code>public</code>、<code>protected</code>、<code>private</code> 等任何区域，和外部类的访问权限相同。</li><li>但外部类不能直接访问内部类的成员，除非通过内部类的对象来访问。</li><li>内部类可以访问外部类的非静态成员，但需要通过外部类的对象来访问。</li></ul></li><li><strong>访问外部类的静态成员</strong>：<ul><li>内部类可以直接访问外部类中的 <code>static</code> 成员，无需外部类的对象或类名。这是因为静态成员是属于类本身的，而不是某个特定对象的。</li></ul></li><li><strong><code>sizeof</code> 外部类和内部类</strong>：<ul><li>外部类和内部类是两个独立的实体，它们占用不同的内存空间。通过 <code>sizeof</code> 计算外部类的大小时，和内部类没有直接关系。</li></ul></li></ol><h3 id="4-3-内部类的分类"><a href="#4-3-内部类的分类" class="headerlink" title="4.3 内部类的分类"></a>4.3 内部类的分类</h3><ul><li><strong>静态内部类</strong>（<code>static</code> nested class）：内部类是静态的，意味着它不需要外部类的实例就可以访问。静态内部类不能访问外部类的实例成员，但可以访问外部类的静态成员。</li><li><strong>非静态内部类</strong>（普通内部类）：需要通过外部类的实例来创建实例，且能够访问外部类的所有成员（包括非静态成员）。</li></ul><h3 id="示例：内部类的使用"><a href="#示例：内部类的使用" class="headerlink" title="示例：内部类的使用"></a>示例：内部类的使用</h3><p>下面我们通过一个例子，详细讲解内部类的使用。</p><h4 id="1-普通的内部类"><a href="#1-普通的内部类" class="headerlink" title="1. 普通的内部类"></a>1. 普通的内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 内部类可以访问外部类的私有成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 private 成员：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 通过内部类访问外部类的成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 private 成员：10</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的内部类。<code>Inner</code> 类可以访问 <code>Outer</code> 类的私有成员 <code>outerVar</code>，并且我们通过 <code>Outer</code> 类的对象来访问外部类的成员。</p><h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 静态内部类可以访问外部类的静态成员</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;访问外部类 static 成员：&quot;</span> &lt;&lt; staticVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Outer::staticVar = <span class="number">20</span>;<span class="comment">// 类外初始化静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer::Inner inner;  <span class="comment">// 创建静态内部类对象</span></span><br><span class="line">    inner.<span class="built_in">accessOuter</span>();  <span class="comment">// 静态内部类访问外部类的静态成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问外部类 static 成员：20</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Inner</code> 是 <code>Outer</code> 类的静态内部类。静态内部类可以直接访问 <code>Outer</code> 类的静态成员 <code>staticVar</code>，不需要外部类的对象。</p><h4 id="3-普通内部类和静态内部类的区别："><a href="#3-普通内部类和静态内部类的区别：" class="headerlink" title="3. 普通内部类和静态内部类的区别："></a>3. 普通内部类和静态内部类的区别：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> outerVar = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">(Outer&amp; outer)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;非静态内部类：&quot;</span> &lt;&lt; outer.outerVar &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">accessOuter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;static 内部类：&quot;</span> &lt;&lt; outerVar &lt;&lt; endl;  <span class="comment">// 编译错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer::Inner inner;</span><br><span class="line">    inner.<span class="built_in">accessOuter</span>(outer);  <span class="comment">// 非静态内部类访问外部类成员</span></span><br><span class="line"></span><br><span class="line">    Outer::StaticInner staticInner;</span><br><span class="line">    <span class="comment">// staticInner.accessOuter();  // 编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO"><a href="#SO" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>内部类</strong> 是定义在另一个类内部的类。它是独立的类，外部类不能直接访问内部类的成员，内部类可以通过外部类的对象访问外部类的所有成员。</li><li><strong>友元关系</strong>：从某种角度看，内部类可以访问外部类的私有成员，所以可以视作外部类的友元类。</li><li>内部类可以是 <strong>静态的</strong>（<code>static</code>），也可以是 <strong>非静态的</strong>，它们的访问权限和行为有所不同。</li></ul><p>内部类通常用于处理一些与外部类紧密相关的功能，帮助将代码组织得更好。</p><hr><h2 id="5-匿名对象（Anonymous-Object）"><a href="#5-匿名对象（Anonymous-Object）" class="headerlink" title="5. 匿名对象（Anonymous Object）"></a>5. 匿名对象（Anonymous Object）</h2><p>在 C++中，匿名对象指的是没有明确名称的对象。它通常用于函数返回、临时数据传递、类型转换等场景，它们的生命周期仅限于它们所在的表达式或者函数调用，执行完毕后即被销毁。通过合理使用匿名对象，可以简化代码、减少不必要的对象创建，提高程序的效率。下面我将详细讲解匿名对象的相关知识点及其使用。</p><h3 id="5-1-匿名对象的定义和创建"><a href="#5-1-匿名对象的定义和创建" class="headerlink" title="5.1 匿名对象的定义和创建"></a>5.1 匿名对象的定义和创建</h3><p>匿名对象是没有名字的临时对象。在 C++中，匿名对象通常出现在以下场景：</p><ul><li><strong>作为函数返回值：</strong> 当函数返回一个对象时，C++会创建一个匿名对象来接收返回值。</li><li><strong>临时对象：</strong> 用作表达式的操作数时，编译器会创建一个临时对象。</li><li><strong>类型转换：</strong> 在类型转换过程中，C++会临时创建匿名对象。</li></ul><h3 id="5-2-匿名对象的生命周期"><a href="#5-2-匿名对象的生命周期" class="headerlink" title="5.2 匿名对象的生命周期"></a>5.2 匿名对象的生命周期</h3><p>匿名对象的生命周期非常短，通常只在一个表达式或者函数调用期间有效。它们会在表达式结束后立即销毁。这是因为它们没有名字，无法直接引用它们。</p><h3 id="5-3-匿名对象的使用示例"><a href="#5-3-匿名对象的使用示例" class="headerlink" title="5.3 匿名对象的使用示例"></a>5.3 匿名对象的使用示例</h3><h4 id="示例-1：作为函数返回值的匿名对象"><a href="#示例-1：作为函数返回值的匿名对象" class="headerlink" title="示例 1：作为函数返回值的匿名对象"></a>示例 1：作为函数返回值的匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回匿名对象</span></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 返回一个匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">createObject</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 创建一个匿名对象并调用它的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>createObject</code> 函数中，<code>return MyClass();</code> 创建了一个匿名对象并返回。</li><li>在 <code>main</code> 函数中，调用 <code>createObject().sayHello()</code> 时，匿名对象在 <code>createObject</code> 函数返回时创建，并且调用 <code>sayHello()</code> 方法。</li><li>程序运行时，首先会打印构造函数的消息，接着打印 <code>sayHello()</code> 的消息，然后销毁匿名对象，打印析构函数的消息。</li></ul><h4 id="示例-2：作为临时对象"><a href="#示例-2：作为临时对象" class="headerlink" title="示例 2：作为临时对象"></a>示例 2：作为临时对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>();  <span class="comment">// 这里是一个匿名对象调用方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>main</code> 函数中，<code>MyClass().sayHello();</code> 创建了一个匿名对象并调用了 <code>sayHello</code> 方法。</li><li>这个匿名对象仅在该行代码执行时有效，执行完后立即销毁。</li></ul><h4 id="示例-3：通过类型转换创建匿名对象"><a href="#示例-3：通过类型转换创建匿名对象" class="headerlink" title="示例 3：通过类型转换创建匿名对象"></a>示例 3：通过类型转换创建匿名对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">m_value</span>(value)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 构造函数：&quot;</span> &lt;&lt; m_value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="number">10</span>);  <span class="comment">// 创建一个匿名对象并传递给构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>MyClass(10);</code> 创建了一个匿名对象，并且传递了参数 <code>10</code> 给构造函数。</li><li>这个匿名对象在创建后立即销毁，生命周期仅限于该行代码。</li></ul><h3 id="5-4-匿名对象的应用场景"><a href="#5-4-匿名对象的应用场景" class="headerlink" title="5.4 匿名对象的应用场景"></a>5.4 匿名对象的应用场景</h3><p>匿名对象有很多实际应用，下面列出一些常见的场景：</p><ol><li><p><strong>临时数据传递：</strong> 在函数调用时传递临时对象，避免了不必要的对象复制。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理传入的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>(<span class="number">5</span>));  <span class="comment">// 创建一个匿名对象并传递</span></span><br></pre></td></tr></table></figure></li><li><p><strong>简化代码：</strong> 当不需要重复使用对象时，可以通过匿名对象来简化代码，避免创建多余的变量。</p></li><li><p><strong>链式调用：</strong> 匿名对象可以用于链式调用多个函数。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">sayHello</span>().<span class="built_in">anotherFunction</span>();  <span class="comment">// 链式调用匿名对象的方法</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="5-5-注意事项"><a href="#5-5-注意事项" class="headerlink" title="5.5 注意事项"></a>5.5 注意事项</h3><ul><li><strong>内存管理：</strong> 匿名对象通常是自动管理的，C++会在它们超出作用域后自动销毁。这意味着开发者不需要手动释放内存，但如果匿名对象涉及到动态内存分配（如 <code>new</code>），则需要特别注意内存管理。</li><li><strong>避免悬挂引用：</strong> 由于匿名对象的生命周期很短，必须避免在它销毁后访问它。</li></ul><blockquote><h2 id="传道解惑-1"><a href="#传道解惑-1" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：为什么匿名对象加-const-可以延长生命周期"><a href="#Q1：为什么匿名对象加-const-可以延长生命周期" class="headerlink" title="Q1：为什么匿名对象加 const 可以延长生命周期?"></a>Q1：为什么匿名对象加 <code>const</code> 可以延长生命周期?</h3><p>将匿名对象加上 <code>const</code> 修饰符，<strong>可以延长其生命周期</strong>。但这种延长的生命周期并不是无条件的，它的背后有一些特定的规则和原理。</p><p>在 C++中，匿名对象的生命周期是由它们的 <strong>作用域</strong> 决定的，通常在一个表达式或函数调用结束时，匿名对象会被销毁。但是，如果将匿名对象声明为 <code>const</code> 类型，它将与一个 <strong>引用</strong> 绑定，从而延长其生命周期。这是因为 <code>const</code> 引用允许我们在对象生命周期结束后，依然通过引用来使用它。</p><h4 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h4><ol><li><strong>匿名对象与临时对象的生命周期：</strong></li></ol><ul><li><p>默认情况下，匿名对象（临时对象）的生命周期通常非常短，仅限于它的表达式或语句的结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>().<span class="built_in">doSomething</span>();  <span class="comment">// 匿名对象在 doSomething() 执行完后销毁</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>使用 <code>const</code> 引用延长生命周期：</strong></li></ol><ul><li>当匿名对象绑定到一个 <code>const</code> 引用时，C++会保证匿名对象的生命周期至少延长到该引用的生命周期结束。也就是说，这个引用会“延迟”对象销毁的时机，直到引用被销毁。</li><li><strong>关键点：</strong> <code>const</code> 引用可以延长临时对象的生命周期，使其存在于引用的作用域中，直到引用超出作用域。</li></ul><p>  示例：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();  <span class="comment">// obj 是对匿名对象的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">    <span class="comment">// 匿名对象在 foo() 返回时才销毁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这个例子中：</p><ul><li><code>MyClass()</code> 创建了一个匿名对象。</li><li>这个匿名对象会被传递给 <code>foo()</code> 函数，并绑定到 <code>const MyClass&amp; obj</code> 上。</li><li>匿名对象的生命周期被延长，直到 <code>obj</code> 超出作用域，也就是 <code>foo()</code> 函数结束。</li></ul><p><strong>临时对象的绑定规则：</strong></p><ul><li>当临时对象（匿名对象）被绑定到一个 <code>const</code> 引用时，C++会延长临时对象的生命周期，直到引用超出作用域。</li><li>这样做的目的是为了避免因临时对象提前销毁而导致引用悬挂问题（即引用一个已销毁的临时对象）。</li></ul><h3 id="例子：匿名对象与-const-引用"><a href="#例子：匿名对象与-const-引用" class="headerlink" title="例子：匿名对象与 const 引用"></a>例子：匿名对象与 <code>const</code> 引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;MyClass 析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;做点什么！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   obj.<span class="built_in">doSomething</span>();  <span class="comment">// 这里 obj 是对匿名对象的引用</span></span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象绑定到 const 引用 obj</span></span><br><span class="line">   <span class="comment">// 匿名对象的生命周期会被延长，直到 processObject 返回</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass 构造函数</span><br><span class="line">&gt;做点什么！</span><br><span class="line">&gt;MyClass 析构函数</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>在 <code>processObject</code> 函数中，<code>MyClass()</code> 创建了一个匿名对象，它被传递并绑定到 <code>const MyClass&amp; obj</code>。</li><li>由于 <code>obj</code> 是 <code>const</code> 引用，匿名对象的生命周期被延长，直到 <code>processObject</code> 函数返回。</li><li>匿名对象的析构函数只会在 <code>processObject</code> 函数结束后调用。</li></ul><h3 id="重要说明："><a href="#重要说明：" class="headerlink" title="重要说明："></a>重要说明：</h3><ul><li><strong><code>const</code> 引用延长生命周期的作用范围：</strong> <code>const</code> 引用的作用是延长临时对象的生命周期，<strong>直到引用超出作用域</strong>。这意味着匿名对象在引用的作用域内存在，引用超出作用域后，匿名对象才会销毁。而这样做是为了避免临时对象在使用时被提前销毁，确保引用对象的有效性。这种机制是 C++中的一种特性，它通过引用的生命周期来保证匿名对象在函数作用域内的安全访问。</li><li><strong>非 <code>const</code> 引用不允许绑定临时对象：</strong> 如果你尝试用一个非 <code>const</code> 引用绑定临时对象，C++ 编译器会报错，因为非 <code>const</code> 引用无法延长临时对象的生命周期。</li></ul><hr><h3 id="Q2：匿名对象-VS-有名对象"><a href="#Q2：匿名对象-VS-有名对象" class="headerlink" title="Q2：匿名对象 VS 有名对象"></a>Q2：匿名对象 VS 有名对象</h3><p><strong>匿名对象</strong> 和 <strong>有名对象</strong> 在 C++中的最大区别在于命名、生命周期以及访问方式。匿名对象通常用于临时需要的场合，生命周期短，而有名对象则用于需要在多个地方访问和操作的情形，生命周期较长。下面我将详细解释：</p><p><strong>命名</strong></p><ul><li><p>匿名对象（Anonymous Object）：顾名思义，它没有明确的名称，通常是临时创建的对象，不会绑定到变量上。</p></li><li><p>例如：<code>MyClass().doSomething();</code>，在这里 <code>MyClass()</code> 创建了一个匿名对象，它没有名称，仅用于调用 <code>doSomething()</code> 方法。</p></li><li><p>有名对象（Named Object）：有明确的名称，可以通过变量名访问。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// obj 是有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();</span><br></pre></td></tr></table></figure></li></ul><p><strong>生命周期</strong></p><ul><li>匿名对象：生命周期非常短暂，仅存在于当前表达式或者语句中，一旦使用完毕，匿名对象会被销毁。</li><li>例如：<code>MyClass().doSomething();</code> 中，匿名对象会在调用 <code>doSomething()</code> 后立刻销毁。</li><li>有名对象：生命周期通常由它的作用域决定。对象在创建时分配内存，并在其作用域结束时被销毁。如果对象在栈上创建，它会在离开作用域时销毁；如果在堆上创建，则需要手动释放内存。</li><li>例如：<code>MyClass obj;</code> 在 <code>obj</code> 离开作用域时销毁。</li></ul><p><strong>访问方式</strong></p><ul><li><strong>匿名对象</strong>：不能通过变量名访问，因为它没有名称。只能在它创建的上下文中直接使用它。</li><li>例如：<code>MyClass().doSomething();</code> 中没有 <code>MyClass</code> 对象的名称，无法在之后访问它。</li><li><strong>有名对象</strong>：可以通过对象的名称来引用和访问对象的成员。</li><li>例如：<code>obj.doSomething();</code> 中，<code>obj</code> 是有名对象，可以在之后的代码中多次使用。</li></ul><p><strong>内存管理</strong></p><ul><li><strong>匿名对象</strong>：由于没有名称，它通常是栈上分配的，编译器在合适的时候自动管理内存。对于返回值优化（RVO&#x2F;NRVO）等，编译器会优化创建匿名对象的内存管理，避免不必要的拷贝。</li><li><strong>有名对象</strong>：有名称，可以显式创建在栈上或堆上。栈上的对象在作用域结束时自动销毁，而堆上的对象则需要手动 <code>delete</code>。</li></ul><p><strong>应用场景</strong></p><p><strong>匿名对象</strong>：</p><ul><li><p>适用于 <strong>临时使用</strong>，例如一次性计算或者在函数调用中使用临时对象。</p></li><li><p>常见于函数返回值、类型转换、临时数据传递等场景。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processObject</span><span class="params">(MyClass obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.<span class="built_in">doSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">                     </span><br><span class="line"><span class="built_in">processObject</span>(<span class="built_in">MyClass</span>());  <span class="comment">// 匿名对象作为参数传递</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>有名对象</strong>：</p><ul><li><p>适用于 <strong>需要多次访问</strong> 的场景，或者需要在多个地方使用该对象。</p></li><li><p>典型用法是作为类的实例，创建时需要明确的对象名来进行后续操作。</p></li><li><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;  <span class="comment">// 有名对象</span></span><br><span class="line">obj.<span class="built_in">doSomething</span>();  <span class="comment">// 可以在后续访问该对象</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>返回值优化（RVO&#x2F;NRVO）</strong></p><ul><li><p><strong>匿名对象</strong> 在函数返回值时，编译器会尽可能优化，避免多余的拷贝操作，这被称为 <strong>返回值优化</strong>（RVO）或者 <strong>命名返回值优化</strong>（NRVO）。这意味着，返回匿名对象时，编译器会直接在调用位置构造返回对象，而不会创建临时对象。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// 匿名对象直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有名对象</strong> 没有这样的优化问题，通常会被拷贝或者移动到调用处，特别是在涉及对象返回时。</p></li></ul><p><strong>性能差异</strong></p><ul><li>匿名对象：由于其生命周期非常短，编译器有时能够优化它们的创建和销毁过程，避免不必要的复制。</li><li>在某些场景中，匿名对象能避免额外的内存分配和释放开销，提升性能。</li><li><strong>有名对象</strong>：虽然生命周期较长，但如果不合理使用，有时会增加额外的开销，尤其是在传递大对象时，可能会发生不必要的拷贝操作。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>特性</th><th>匿名对象</th><th>有名对象</th></tr></thead><tbody><tr><td><strong>命名</strong></td><td>没有名称，仅为临时对象</td><td>有名称，可以通过变量名访问</td></tr><tr><td><strong>生命周期</strong></td><td>短暂，仅在表达式或函数调用期间存在</td><td>生命周期由作用域决定，作用域结束时销毁</td></tr><tr><td><strong>访问方式</strong></td><td>不能直接访问，通常仅在当前表达式中使用</td><td>可以通过名称多次访问</td></tr><tr><td><strong>内存管理</strong></td><td>编译器自动管理内存，通常是栈上分配</td><td>可以是栈上或堆上，需要显式管理堆对象的内存</td></tr><tr><td><strong>应用场景</strong></td><td>临时数据传递、返回值、一次性计算等</td><td>需要多次使用、存储数据或状态等</td></tr><tr><td><strong>性能差异</strong></td><td>编译器优化可能避免不必要的复制</td><td>如果不小心使用，可能有不必要的拷贝操作### 总结</td></tr></tbody></table></blockquote><hr><h2 id="6-再次理解类和对象"><a href="#6-再次理解类和对象" class="headerlink" title="6. 再次理解类和对象"></a>6. 再次理解类和对象</h2><p>理解 <strong>类</strong> 和 <strong>对象</strong> 的概念，能帮助我们更好地理解面向对象编程（OOP）的核心思想。为了更通俗地讲解这个内容，我们可以通过一个现实中的例子来帮助理解。</p><h3 id="1-类是对事物的抽象"><a href="#1-类是对事物的抽象" class="headerlink" title="1. 类是对事物的抽象"></a>1. 类是对事物的抽象</h3><p>类就像是对某种 <strong>事物</strong>（例如洗衣机）的 <strong>抽象描述</strong>。它是 <strong>对现实中事物的建模</strong>，在程序中描述这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</p><ul><li><strong>属性</strong>：就是这个事物的特征，比如洗衣机的品牌、颜色、容量等。</li><li><strong>行为</strong>：就是这个事物可以做的事情，比如洗衣机可以“启动”、“停止”、“洗衣服”等。</li></ul><p>举个例子，洗衣机这个事物可以用类来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（比如5kg、10kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;    <span class="comment">// 启动洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;      <span class="comment">// 停止洗衣机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>WashingMachine</code> 类描述了一个洗衣机的 <strong>属性</strong>（<code>brand</code>, <code>color</code>, <code>capacity</code>）和 <strong>行为</strong>（<code>start()</code>，<code>stop()</code>）。这个类的作用就是 <strong>抽象化</strong> 洗衣机，将它的特征和行为描述给计算机。</p><h3 id="2-对象是类的实例化"><a href="#2-对象是类的实例化" class="headerlink" title="2. 对象是类的实例化"></a>2. 对象是类的实例化</h3><p>类是对现实事物的抽象描述，但计算机无法直接“认识”类，必须通过 <strong>实例化</strong> 类来创建 <strong>对象</strong>，而对象才是计算机可以操作的具体实体。</p><ul><li><strong>实例化</strong>：就是通过类创建具体的对象的过程。</li><li><strong>对象</strong>：是类的具体实例，表示现实世界中的某个具体的事物。比如，你可以通过 <code>WashingMachine</code> 类创建多个洗衣机对象，每个对象代表一个具体的洗衣机。</li></ul><p>例子继续，假设我们现在创建了一个洗衣机对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WashingMachine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string brand;      <span class="comment">// 洗衣机的品牌</span></span><br><span class="line">    string color;      <span class="comment">// 洗衣机的颜色</span></span><br><span class="line">    <span class="type">int</span> capacity;      <span class="comment">// 洗衣机的容量（单位：kg）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine started.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing machine stopped.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wash</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Washing clothes...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WashingMachine wm1;</span><br><span class="line">    wm<span class="number">1.</span>brand = <span class="string">&quot;小米&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>color = <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">    wm<span class="number">1.</span>capacity = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">start</span>();  <span class="comment">// 启动洗衣机</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">wash</span>();   <span class="comment">// 洗衣服</span></span><br><span class="line">    wm<span class="number">1.</span><span class="built_in">stop</span>();   <span class="comment">// 停止洗衣机</span></span><br><span class="line"></span><br><span class="line">    WashingMachine wm2;</span><br><span class="line">    wm<span class="number">2.</span>brand = <span class="string">&quot;格力&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>color = <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line">    wm<span class="number">2.</span>capacity = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">start</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">wash</span>();</span><br><span class="line">    wm<span class="number">2.</span><span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>wm1</code> 和 <code>wm2</code> 是 <code>WashingMachine</code> 类的两个 <strong>对象</strong>。它们分别代表两个不同的洗衣机，每个对象的属性（<code>brand</code>, <code>color</code>, <code>capacity</code>）可以有不同的值。通过这些对象，我们可以模拟现实中的多个洗衣机。</p><h3 id="3-通过类创建对象"><a href="#3-通过类创建对象" class="headerlink" title="3. 通过类创建对象"></a>3. 通过类创建对象</h3><p>从以上的例子可以看出，类只是描述了洗衣机的属性和行为，而对象才是 <strong>具体的实例</strong>。你可以通过类创建出多个对象，每个对象都代表一个具体的事物。类就像是一个模板或蓝图，具体的对象是根据这个模板生成的。</p><h3 id="4-类和对象的关系"><a href="#4-类和对象的关系" class="headerlink" title="4. 类和对象的关系"></a>4. 类和对象的关系</h3><ul><li><strong>类</strong> 是对 <strong>事物</strong> 的一种描述，它定义了这个事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的 <strong>实例</strong>，是计算机可以直接操作的具体实体。通过类可以创建多个对象，每个对象都有不同的属性值和方法。</li></ul><p>总结一下，类和对象的关系可以类比为：</p><ul><li><strong>类</strong>：就像是一本 <strong>描述洗衣机的说明书</strong>，它告诉我们洗衣机有哪些属性（品牌、颜色、容量）和行为（启动、停止）。</li><li><strong>对象</strong>：就像是根据这本说明书实际生产出来的 <strong>具体洗衣机</strong>。每一台洗衣机都有自己的品牌、颜色、容量等信息，并可以执行启动、停止等操作。</li></ul><h3 id="5-现实中的例子：洗衣机类"><a href="#5-现实中的例子：洗衣机类" class="headerlink" title="5. 现实中的例子：洗衣机类"></a>5. 现实中的例子：洗衣机类</h3><p>让我们通过现实中的洗衣机来进一步理解。</p><ol><li><strong>抽象洗衣机</strong>：当我们想到洗衣机时，我们并不会想到具体某一台洗衣机，而是先想到了“洗衣机”这个概念。它有品牌、颜色、容量这些特征，并且有启动、停止这些操作。这就是 <strong>类</strong> 的作用：把这些共性的特征和行为总结出来。</li><li><strong>创建洗衣机对象</strong>：当你去买洗衣机时，你选择了一个品牌、颜色、容量等具体参数的洗衣机。每一台洗衣机就是一个 <strong>对象</strong>，它是类的实例化。</li><li><strong>操作洗衣机</strong>：当你开始使用这台洗衣机时，你可以通过按按钮来“启动”和“停止”，这就是对象通过类提供的操作（方法）来实现的行为。</li></ol><hr><h3 id="SO-1"><a href="#SO-1" class="headerlink" title="SO:"></a>SO:</h3><ul><li><strong>类</strong> 是对现实世界中事物的抽象描述，它总结了事物的 <strong>属性</strong> 和 <strong>行为</strong>。</li><li><strong>对象</strong> 是类的具体实例，是计算机能够识别和操作的实体。</li><li><strong>类</strong> 是对事物的抽象描述，而 <strong>对象</strong> 是根据类创建的具体实例。</li><li>通过 <strong>类</strong>，我们可以创建多个不同的 <strong>对象</strong>，每个对象具有类中定义的属性和行为。</li></ul><p>通过理解类和对象的关系，你将能够更好地理解面向对象编程（OOP）的核心思想，这对于学习和使用 C++、Java 等面向对象语言非常重要。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象（中）</title>
      <link href="/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2025/04/02/03%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类的-6-个默认成员函数"><a href="#1-类的-6-个默认成员函数" class="headerlink" title="1. 类的 6 个默认成员函数"></a>1. 类的 6 个默认成员函数</h2><p><strong>默认成员函数的含义</strong>：<br> 即使一个类什么都不写，编译器也会默认生成 <code>4</code> 以下个成员函数：</p><ol><li><strong>默认构造函数</strong>（初始化对象时调用）。</li><li><strong>拷贝构造函数</strong>（用已有对象创建新对象时调用）。</li><li><strong>析构函数</strong>（对象生命周期结束时调用）。</li><li><strong>赋值运算符重载</strong>（用 <code>=</code> 赋值时调用）。</li></ol><p>可以直接使用的操作符：</p><ol><li><strong>取地址操作符</strong> <code>&amp;</code>。</li><li><strong>常量取地址操作符</strong> <code>const &amp;</code>。</li></ol><p><strong>代码示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空类，未显式定义任何成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example e1;  <span class="comment">// 调用默认构造函数</span></span><br><span class="line">    Example e2 = e1;  <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    Example* ePtr = &amp;e1;  <span class="comment">// 调用取地址操作符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 在程序结束时，e1 和 e2 调用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑："><a href="#传道解惑：" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：e1——类的实例化："><a href="#Q1：e1——类的实例化：" class="headerlink" title="Q1：e1——类的实例化："></a>Q1：<code>e1</code>——类的实例化：</h3><ul><li><strong>实例化</strong>（Instantiating）指的是通过类来创建对象的过程。当你写出类似 <code>Example e1;</code> 的代码时，<code>e1</code> 就是 <code>Example</code> 类的一个实例（对象）。实例化的本质就是通过类（<code>Example</code>）来创建一个具体的对象（<code>e1</code>）。</li><li><strong>类</strong> 是一种模板或者蓝图，它描述了对象的属性和行为，但它本身不是一个具体的对象。类可以看作是定义对象的结构和功能，而实例化就是将类的结构和功能变成一个可以使用的具体对象。</li></ul><p><strong>举个例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> value;  <span class="comment">// 类的成员</span></span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   Example e1;  <span class="comment">// 创建一个名为 e1 的 Example 类对象</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Example</code> 是一个类，定义了一个成员变量 <code>value</code>。</li><li><code>e1</code> 是通过 <code>Example</code> 类进行实例化的对象。它是 <code>Example</code> 类的一个具体实例。</li></ul><hr><h3 id="Q2：ePtr-——-Example-类的指针："><a href="#Q2：ePtr-——-Example-类的指针：" class="headerlink" title="Q2：ePtr —— Example 类的指针："></a>Q2：<code>ePtr</code> —— <code>Example</code> 类的指针：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Example* ePtr = &amp;e1;</span><br></pre></td></tr></table></figure><ul><li><code>ePtr</code> 是一个指向 <code>Example</code> 类对象的指针。<code>Example*</code> 表示“指向 <code>Example</code> 类的指针”。</li><li><code>&amp;e1</code> 表示取 <code>e1</code> 对象的地址，也就是 <code>ePtr</code> 指向 <code>e1</code> 的内存位置。</li><li><code>ePtr</code> 可以通过指针操作访问 <code>e1</code> 对象的成员（虽然在这个示例中 <code>Example</code> 类没有成员）。</li></ul></blockquote><p>&#x3D;&#x3D;<strong>注意</strong>&#x3D;&#x3D;：如果用户显式定义任何一个成员函数，编译器将不再生成对应的默认版本。</p><hr><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h2><p><strong>构造函数</strong>（Constructor）：是类的一个特殊成员函数，用于在创建对象时进行初始化。构造函数的名字与类名相同，并且没有返回值。它可以是 <strong>无参构造函数</strong>（即默认构造函数）或者 <strong>带参构造函数</strong>（即带参数的构造函数），主要是用于初始化对象的成员函数，可以有参数。</p><ul><li><strong>无参构造函数</strong>（Default Constructor）：也称作 <strong>默认构造函数</strong>，是一种特殊类型的构造函数，<strong>没有参数</strong>。它用于当创建对象时不需要传递任何参数，如果类没有其他构造函数，编译器通常会自动提供一个默认的版本。（<strong>所以</strong>，默认构造函数是一种特殊的构造函数，是构造函数的一种形式，可以是显式定义的，也可以是编译器自动生成的，通常在创建对象时，如果没有传递任何参数，就会调用它）</li><li><strong>带参构造函数</strong>（Parameterized Constructor）：是另一种构造函数，它 <strong>带有参数</strong>，在创建对象时，通过传递不同的参数来定制对象的初始化。</li></ul><blockquote><p>构造函数是 C++ 中用于初始化对象的特殊函数。它的名字虽然叫“构造”，但它的主要任务不是开辟内存空间，而是初始化对象的成员变量。以下是构造函数 <code>7</code> 个特征：</p><h4 id="1-函数名与类名相同"><a href="#1-函数名与类名相同" class="headerlink" title="1. 函数名与类名相同"></a>1. 函数名与类名相同</h4><ul><li><p>构造函数的名字和类名完全一样，这是 C++ 的规定，用于识别构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 初始化代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无返回值"><a href="#2-无返回值" class="headerlink" title="2. 无返回值"></a>2. 无返回值</h4><ul><li>构造函数没有返回值，也不能定义返回类型（包括 <code>void</code>）。</li><li>理由：构造函数的目的是初始化对象，不需要返回任何东西，调用它的结果就是一个已初始化的对象。</li></ul><h4 id="3-对象实例化时，自动调用构造函数"><a href="#3-对象实例化时，自动调用构造函数" class="headerlink" title="3. 对象实例化时，自动调用构造函数"></a>3. 对象实例化时，自动调用构造函数</h4><ul><li>构造函数会在对象创建时由编译器自动调用，无需显式调用。例如：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;构造函数被调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动调用构造函数</span></span><br></pre></td></tr></table></figure><h4 id="4-构造函数可以重载"><a href="#4-构造函数可以重载" class="headerlink" title="4. 构造函数可以重载"></a>4. 构造函数可以重载</h4><ul><li><p>构造函数支持重载（即可以有多个构造函数，但参数列表必须不同）。</p></li><li><p>通过重载，用户可以根据需要初始化对象：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 无参构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 带参数的构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;MyClass obj1;     <span class="comment">// 调用无参构造函数</span></span><br><span class="line">&gt;<span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 调用带参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认构造函数的生成规则"><a href="#5-默认构造函数的生成规则" class="headerlink" title="5. 默认构造函数的生成规则"></a>5. 默认构造函数的生成规则</h4><ul><li><p>如果类中没有显式定义无参构造函数，编译器会自动生成一个默认无参构造函数。</p></li><li><p>如果用户显式定义了任意构造函数（无论是否带参数），编译器将不再生成默认无参构造函数，除非显式定义一个无参构造函数。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass obj; <span class="comment">// 自动生成无参默认构造函数</span></span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass2</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass2</span>(<span class="type">int</span> y) &#123;&#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line">&gt;MyClass2 obj2; <span class="comment">// 错误，因为没有无参构造函数</span></span><br></pre></td></tr></table></figure><h4 id="6-默认构造函数对内置和自定义类型的处理"><a href="#6-默认构造函数对内置和自定义类型的处理" class="headerlink" title="6. 默认构造函数对内置和自定义类型的处理"></a>6. 默认构造函数对内置和自定义类型的处理</h4><ul><li><p><strong>内置类型（如 <code>int</code>, <code>char</code>）</strong>：</p></li><li><p>默认构造函数不会初始化内置类型成员，成员变量可能是随机值。例如：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 默认值是随机的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>解决方法：使用 C++11 提供的默认值：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>; <span class="comment">// 默认值为 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><strong>自定义类型（如 <code>class</code>, <code>struct</code>）</strong>：</p></li><li><p>编译器生成的默认构造函数会调用这些类型成员的默认构造函数。</p></li><li><p>例子：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    Inner obj; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Outer obj; <span class="comment">// 实例化自定义类型成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：Inner 构造函数</span><br></pre></td></tr></table></figure><h4 id="7-默认构造函数的种类"><a href="#7-默认构造函数的种类" class="headerlink" title="7. 默认构造函数的种类"></a>7. 默认构造函数的种类</h4><p><strong>无参的构造函数</strong> 和 <strong>全缺省的构造函数</strong>（所有参数都有默认值的构造函数）都称为 <strong>默认构造函数</strong>，并且默认构造函数只能有一个。</p><p>注意：无参构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数，都可以认为是默认构造函数。</p><ul><li><p><strong>无参构造函数</strong>：没有任何参数的构造函数。</p></li><li><p><strong>全缺省构造函数</strong>：所有参数都有默认值的构造函数。 两者都属于默认构造函数的范畴，但它们的定义和使用场景有所不同。</p></li><li><p>例子：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>() &#123;&#125; <span class="comment">// 无参构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;&#125; <span class="comment">// 全缺省构造函数</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><p>构造函数的核心是初始化对象的成员，而非创建内存空间。默认构造函数的行为取决于对象成员的类型：</p><ul><li>内置类型成员默认不初始化，可能是随机值。</li><li>自定义类型成员会自动调用其默认构造函数。</li></ul><p>通过合理设计构造函数，可以确保对象在创建时处于有效的初始状态。（在 C++11 及更高版本中，编译器还会生成 <strong>移动构造函数</strong> 和 <strong>移动赋值运算符</strong>，用于优化资源管理。这些函数允许对象在移动语义下高效地转移资源，而不是进行拷贝。例如，移动构造函数可以将一个临时对象的资源直接转移给新对象，避免不必要的拷贝操作。这些内容将在后续章节中详细介绍。）</p></blockquote><h3 id="2-1-无参构造函数（默认构造函数）"><a href="#2-1-无参构造函数（默认构造函数）" class="headerlink" title="2.1. 无参构造函数（默认构造函数）"></a>2.1. 无参构造函数（默认构造函数）</h3><p>没有参数，创建对象时会被默认调用。</p><ul><li>如果用户没有定义任何构造函数，编译器会生成一个无参构造函数。</li><li>一旦用户定义了任何构造函数，编译器将不再生成。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        year = <span class="number">2025</span>;</span><br><span class="line">        month = <span class="number">1</span>;</span><br><span class="line">        day = <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;<span class="comment">// 私有成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d;  <span class="comment">// 调用无参构造函数，注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明</span></span><br><span class="line">    d.<span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-带参构造函数"><a href="#2-2-带参构造函数" class="headerlink" title="2.2 带参构造函数"></a>2.2 带参构造函数</h3><p>可接受参数，并根据用户输入初始化对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span><br><span class="line">        : <span class="built_in">year</span>(y), </span><br><span class="line">    <span class="built_in">month</span>(m), </span><br><span class="line">    <span class="built_in">day</span>(d)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果只定义了带参构造函数，编译器不会生成默认无参构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 正常调用</span></span><br><span class="line">    <span class="comment">// Date d2; // 错误：没有默认无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h2 id="传道解惑：-1"><a href="#传道解惑：-1" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：公有（public）私有（private）部分的关系："><a href="#Q1：公有（public）私有（private）部分的关系：" class="headerlink" title="Q1：公有（public）私有（private）部分的关系："></a>Q1：公有（public）私有（private）部分的关系：</h3><p>在 C++ 中，类的成员（变量和函数）可以被指定为 <strong>公有（public）</strong> 或 <strong>私有（private）</strong>，这些访问控制符决定了成员的访问权限。接下来，我会详细讲解 <strong>公有部分</strong> 和 <strong>私有部分</strong> 的作用和关系。</p><p><strong>公有部分（public）</strong></p><ul><li><strong>访问权限：</strong> 任何外部代码（比如 <code>main()</code> 函数）都可以直接访问和修改公有成员。简单来说，<strong>公有部分</strong> 的成员对外部可见。</li><li><strong>适用场景：</strong> 一般情况下，我们会将类中的 <strong>接口函数</strong> 或 <strong>需要外部访问的数据</strong> 声明为公有，以便外部能够与对象交互。</li></ul><p><strong>私有部分（private）</strong></p><ul><li><strong>访问权限：</strong> 私有成员 <strong>只能在类内部的成员函数中访问</strong>，外部的代码无法直接访问或修改这些成员。<strong>私有部分</strong> 用于隐藏类的内部实现细节，只允许通过公有的接口与外部交互。</li><li><strong>适用场景：</strong> 私有成员通常是 <strong>类的内部数据</strong>，这些数据不希望被外部代码随意修改。通过这种方式，我们可以控制数据的访问权限和保证数据的正确性（通过公有函数进行访问或修改）。</li></ul><p><strong>关系</strong></p><ul><li><strong>数据封装（Encapsulation）：</strong> 这就是面向对象编程的核心之一，即将数据和操作数据的代码封装在一起。私有成员数据保护了对象的内部状态，避免了外部对数据的不恰当修改。公有函数则为外部提供了访问和修改数据的接口。</li><li><strong>分离接口与实现：</strong> 通过将接口函数（如 <code>Print()</code>）放在公有部分，类的使用者只需关心接口如何使用，而不需要知道具体的实现方式。私有部分负责实现细节，公有部分提供与外界的交互。</li><li><strong>保护：</strong> 私有成员提供类的内部实现，而公有成员则提供与外部的交互接口。这种设计有助于 <strong>封装</strong> 和 <strong>数据保护</strong>，确保类的使用者不破坏对象的状态。</li></ul><hr><h3 id="Q2：私有变量是否必须在公有部分出现？"><a href="#Q2：私有变量是否必须在公有部分出现？" class="headerlink" title="Q2：私有变量是否必须在公有部分出现？"></a>Q2：私有变量是否必须在公有部分出现？</h3><p><strong>不需要。</strong></p><p>类中的私有变量 (<code>private</code>) 是可以仅供类内部使用的，它们不一定需要通过公有部分 (<code>public</code>) 暴露出来。私有成员通常是不公开给外部的，所以是非必须出现在公有部分的。实际上，<strong>类的设计应该遵循数据隐藏原则</strong>：即只有通过公有函数，外部才能间接地访问或修改私有数据。这样能保护数据的完整性，避免外部代码直接改变私有数据。如果你希望外部能够访问和操作这些私有变量，通常会提供一些公有方法（如 <code>getter</code> 和 <code>setter</code>）来间接操作它们，但这不是强制的。</p><h3 id="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"><a href="#Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？" class="headerlink" title="Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？"></a>Q3：关于编译器生成的默认成员函数，在不实现构造函数的情况下，编译器会生成默认的构造函数。但是看起来默认构造函数又没什么用？对象调用了编译器生成的默认构造函数，但是对象里依旧是随机值。也就是说，在这里编译器生成的默认构造函数并没有什么用？</h3><p>解答：C++把类型分成内置类型(基本类型)和自定义类型。内置类型就是语言提供的数据类型，如：<code>int/char...</code>，自定义类型就是我们使用 <code>class/struct/union</code> 等自己定义的类型，编译器生成默认的构造函数会对自定义类型成员调用的它的默认成员函数。<strong>即编译器生成的默认构造函数在类的成员变量是自定义类型（非内置类型）时，会自动调用这些自定义类型的默认构造函数。这是 C++ 的一个机制，用于确保对象的每个成员都得到正确的初始化。</strong></p><p><strong>具体解释</strong></p><ol><li><strong>内置类型（如 <code>int</code>、<code>float</code> 等）：</strong></li></ol><ul><li><p>编译器生成的默认构造函数不会对内置类型成员进行初始化，这些成员会是随机值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 内置类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line">                                        </span><br><span class="line">MyClass obj; <span class="comment">// 编译器生成的默认构造函数不会初始化 x</span></span><br><span class="line">cout &lt;&lt; obj.x; <span class="comment">// 随机值</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>自定义类型（如 <code>class</code> 或 <code>struct</code>）：</strong></li></ol><ul><li><p>如果类中包含自定义类型的成员变量，编译器生成的默认构造函数会自动调用这些成员的默认构造函数，以初始化它们。</p></li><li><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inner</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inner 的默认构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Inner innerMember; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Outer obj; <span class="comment">// 自动调用编译器生成的默认构造函数</span></span><br><span class="line"></span><br><span class="line">输出：Inner 的默认构造函数被调用</span><br></pre></td></tr></table></figure></li><li><p>在这个例子中，<code>Outer</code> 类没有显式定义构造函数，但编译器生成了一个默认构造函数。而这个默认构造函数在初始化 <code>innerMember</code> 时，自动调用了 <code>Inner</code> 类的默认构造函数。</p></li></ul><p><strong>为什么这样设计？</strong></p><ul><li>自定义类型的对象可能需要复杂的初始化工作，比如为动态分配内存、初始化状态等。默认构造函数确保这些工作在创建对象时正确完成。</li><li>内置类型如 <code>int</code>、<code>float</code> 等通常不需要调用构造函数，默认值可以通过 C++11 中的默认值赋予。</li></ul><p>当类中有自定义类型的成员变量时：</p><ol><li>如果没有显式定义构造函数，编译器会生成一个默认构造函数。</li><li>这个默认构造函数会对 <strong>自定义类型成员变量</strong> 调用它们自己的默认构造函数，确保它们被正确初始化。</li></ol><p>这意味着你无需手动初始化这些成员，自定义类型的构造函数会自动运行完成初始化工作。</p></blockquote><hr><h2 id="3-析构函数"><a href="#3-析构函数" class="headerlink" title="3. 析构函数"></a>3. 析构函数</h2><p>析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而 <strong>对象在销毁时会自动调用析构函数，完成对象中资源的清理工作</strong>。即用于释放资源。</p><p>析构函数是 C++中的一个特殊成员函数，专门用于对象生命周期结束时释放资源。以下是对上述特征的通俗易懂的解释：</p><blockquote><h3 id="3-1-析构函数的-6-个特征："><a href="#3-1-析构函数的-6-个特征：" class="headerlink" title="3.1 析构函数的 6 个特征："></a>3.1 析构函数的 <code>6</code> 个特征：</h3><h4 id="1-析构函数的命名规则：类名前加字符"><a href="#1-析构函数的命名规则：类名前加字符" class="headerlink" title="1. 析构函数的命名规则：类名前加字符 ~"></a>1. 析构函数的命名规则：类名前加字符 <code>~</code></h4><p>析构函数的名字和类名类似，但前面加了一个波浪号 <code>~</code>，它是 C++的规定，用来显式区分析构函数。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">// 析构代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-无参数、无返回值类型"><a href="#2-无参数、无返回值类型" class="headerlink" title="2. 无参数、无返回值类型"></a>2. 无参数、无返回值类型</h4><p>析构函数不接受任何参数，也不能返回任何值。它的作用是清理资源，而不是用来进行复杂的逻辑处理，因此不需要参数或返回值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;~<span class="built_in">MyClass</span>(); <span class="comment">// 不允许带参数或返回值</span></span><br></pre></td></tr></table></figure><h4 id="3-一个类只能有一个析构函数，且不能重载"><a href="#3-一个类只能有一个析构函数，且不能重载" class="headerlink" title="3. 一个类只能有一个析构函数，且不能重载"></a>3. 一个类只能有一个析构函数，且不能重载</h4><p>析构函数唯一且不能有多个版本。C++编译器在编译时，知道如何自动调用析构函数，因此多版本没有意义。</p><h4 id="4-对象生命周期结束时，自动调用析构函数"><a href="#4-对象生命周期结束时，自动调用析构函数" class="headerlink" title="4. 对象生命周期结束时，自动调用析构函数"></a>4. 对象生命周期结束时，自动调用析构函数</h4><p>当一个对象不再需要时（如超出作用域、程序结束或显式删除时），C++编译器会自动调用析构函数，无需手动调用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">   MyClass obj; <span class="comment">// 创建对象，调用构造函数</span></span><br><span class="line">&gt;&#125; <span class="comment">// 作用域结束，析构函数自动调用</span></span><br></pre></td></tr></table></figure><p>如果对象是动态分配的，用 <code>delete</code> 释放时也会调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass* p = <span class="keyword">new</span> <span class="built_in">MyClass</span>(); <span class="comment">// 动态创建对象</span></span><br><span class="line">&gt;<span class="keyword">delete</span> p; <span class="comment">// 自动调用析构函数</span></span><br></pre></td></tr></table></figure><h4 id="5-默认析构函数：处理类中自定义类型成员的析构"><a href="#5-默认析构函数：处理类中自定义类型成员的析构" class="headerlink" title="5. 默认析构函数：处理类中自定义类型成员的析构"></a>5. 默认析构函数：处理类中自定义类型成员的析构</h4><p>如果没有显式定义析构函数，编译器会生成一个 <strong>默认析构函数</strong>。它会对类中所有非基本类型的成员调用其析构函数，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">   std::string str; <span class="comment">// 自定义类型成员</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>编译器生成的默认析构函数会自动调用 <code>std::string</code> 的析构函数，释放其内部的资源。</p><h4 id="6-没有资源时可以不写，有资源时必须写"><a href="#6-没有资源时可以不写，有资源时必须写" class="headerlink" title="6. 没有资源时可以不写，有资源时必须写"></a>6. 没有资源时可以不写，有资源时必须写</h4><ul><li><strong>没有资源</strong>：如果类中没有动态分配的资源，直接使用编译器生成的默认析构函数即可，在这种情况下，系统生成的默认析构函数已经足够。比如：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day; <span class="comment">// 无动态资源</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>有资源</strong>：如果类中有动态分配的资源（如 <code>new</code> 申请的内存），一定要定义析构函数，手动释放这些资源，否则会造成 <strong>内存泄漏</strong>：</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">// 动态分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Stack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] arr; <span class="comment">// 释放内存，避免泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>析构函数的核心作用是 <strong>清理资源</strong>，尤其是在有动态分配资源的情况下。如果没有动态资源，则可以省略不写。C++的编译器会在合适的时候自动调用析构函数，无需我们手动干预。<strong>记住</strong>：如果忘记写析构函数释放资源，程序可能会导致 <strong>内存泄漏</strong>，尤其是当类中包含动态内存时！</p></blockquote><blockquote><h3 id="3-2-示例："><a href="#3-2-示例：" class="headerlink" title="3.2 示例："></a>3.2 示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ~<span class="built_in">Example</span>()</span><br><span class="line">       &#123;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;析构函数被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">       &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">       Example e;  <span class="comment">// 创建对象时调用构造函数</span></span><br><span class="line">       <span class="comment">// 程序结束时，e 被销毁，析构函数自动调用</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;构造函数被调用</span><br><span class="line">&gt;析构函数被调用</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是 C++ 中的一个特殊构造函数，用于 <strong>通过已有对象初始化一个新对象</strong>（创建一个与已有对象内容完全相同的新对象）。</p><blockquote><h2 id="4-1-拷贝构造函数的-5-个特征："><a href="#4-1-拷贝构造函数的-5-个特征：" class="headerlink" title="4.1 拷贝构造函数的 5 个特征："></a>4.1 拷贝构造函数的 <code>5</code> 个特征：</h2><h4 id="1-拷贝构造函数是构造函数的一个重载形式"><a href="#1-拷贝构造函数是构造函数的一个重载形式" class="headerlink" title="1. 拷贝构造函数是构造函数的一个重载形式"></a>1. 拷贝构造函数是构造函数的一个重载形式</h4><ul><li><p>拷贝构造函数和普通构造函数一样是初始化对象的，但它专门用于用 <strong>另一个对象</strong> 初始化当前对象。</p></li><li><p>它是构造函数的一种重载形式，形式如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 拷贝构造函数声明</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意：拷贝构造函数的名字和类名一样，只是参数是当前类对象的引用。</li></ul><h4 id="2-参数必须是类类型的引用"><a href="#2-参数必须是类类型的引用" class="headerlink" title="2. 参数必须是类类型的引用"></a>2. 参数必须是类类型的引用</h4><ul><li>拷贝构造函数的参数只能是 <strong>类类型的引用</strong>，不能用 <strong>值传递</strong>，否则会导致编译器报错或发生死循环：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass obj); <span class="comment">// 错误，值传递会导致递归调用</span></span><br></pre></td></tr></table></figure><ul><li>这是因为：</li></ul><ol><li>如果参数使用值传递（<code>MyClass obj</code>），在传递参数时会调用拷贝构造函数。</li><li>拷贝构造函数又会调用自己，导致无限递归，最终栈溢出。</li></ol><ul><li>正确形式：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj); <span class="comment">// 使用引用，避免递归</span></span><br></pre></td></tr></table></figure><h4 id="3-默认拷贝构造函数"><a href="#3-默认拷贝构造函数" class="headerlink" title="3. 默认拷贝构造函数"></a>3. 默认拷贝构造函数</h4><ul><li>如果用户没有显式定义拷贝构造函数，<strong>编译器会自动生成一个默认的拷贝构造函数</strong>。</li><li>默认拷贝构造函数会逐字节拷贝对象的成员变量，这种拷贝被称为 <strong>浅拷贝</strong>。</li></ul><p><strong>浅拷贝的含义：</strong></p><ul><li>对于 <strong>内置类型</strong>（如 <code>int</code>、<code>float</code>），直接复制值。</li><li>对于 <strong>自定义类型</strong> 成员，编译器会调用这些成员自己的拷贝构造函数。</li><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> a;</span><br><span class="line">   <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">MyClass</span>() : <span class="built_in">a</span>(<span class="number">0</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">a</span>(other.a), <span class="built_in">p</span>(other.p) &#123;&#125;<span class="comment">// 拷贝构造函数（浅拷贝）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 析构函数，用于释放动态分配的内存</span></span><br><span class="line">   ~<span class="built_in">MyClass</span>()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">delete</span> p;<span class="comment">// 如果 p 指向动态分配的内存，释放它</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj1;</span><br><span class="line">   obj<span class="number">1.</span>a = <span class="number">10</span>;</span><br><span class="line">   obj<span class="number">1.</span>p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>); <span class="comment">// 动态分配内存</span></span><br><span class="line"></span><br><span class="line">   MyClass obj2 = obj1; <span class="comment">// 浅拷贝：obj2 会与 obj1 共享相同的指针 p</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出 obj1 和 obj2 的值</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj1.a = &quot;</span> &lt;&lt; obj<span class="number">1.</span>a &lt;&lt; <span class="string">&quot;, obj1.p = &quot;</span> &lt;&lt; *obj<span class="number">1.</span>p &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;obj2.a = &quot;</span> &lt;&lt; obj<span class="number">2.</span>a &lt;&lt; <span class="string">&quot;, obj2.p = &quot;</span> &lt;&lt; *obj<span class="number">2.</span>p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 手动释放 obj1 的动态内存</span></span><br><span class="line">   <span class="keyword">delete</span> obj<span class="number">1.</span>p;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 现在 obj2.p 是悬空指针，访问它会导致未定义行为</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; &quot;obj2.p after obj1.delete: &quot; &lt;&lt; *obj2.p &lt;&lt; endl; // 危险！</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：如果类中有指针等动态资源，浅拷贝会导致问题。比如 <code>obj1.p</code> 和 <code>obj2.p</code> 指向同一块内存，释放时可能导致重复释放（<strong>悬空指针</strong>）。</p><h4 id="4-是否需要显式定义拷贝构造函数？"><a href="#4-是否需要显式定义拷贝构造函数？" class="headerlink" title="4. 是否需要显式定义拷贝构造函数？"></a>4. 是否需要显式定义拷贝构造函数？</h4><ul><li><p><strong>没有动态资源时（不涉及指针或资源申请）：</strong> 编译器生成的默认拷贝构造函数已经可以正常工作，可以不写。</p></li><li><p><strong>有动态资源时（涉及指针或资源申请）：</strong> 必须显式定义拷贝构造函数，完成深拷贝，避免内存管理问题。</p></li><li><p><strong>深拷贝的实现：</strong> 深拷贝指的是重新分配内存，并复制内容，而不是直接复制指针地址：</p></li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a = obj.a;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.p); <span class="comment">// 深拷贝，重新分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;  <span class="comment">// 释放动态资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-拷贝构造函数的典型调用场景"><a href="#5-拷贝构造函数的典型调用场景" class="headerlink" title="5. 拷贝构造函数的典型调用场景"></a>5. 拷贝构造函数的典型调用场景</h4><ul><li><strong>场景 1：使用已有对象创建新对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass obj1;       <span class="comment">// 普通构造函数</span></span><br><span class="line">&gt;MyClass obj2 = obj1; <span class="comment">// 拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 2：函数参数为类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 如果不使用引用，会调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ul><li><strong>场景 3：函数返回类类型对象</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function">MyClass <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   MyClass obj;</span><br><span class="line">   <span class="keyword">return</span> obj; <span class="comment">// 返回时可能调用拷贝构造函数</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="提高效率的建议"><a href="#提高效率的建议" class="headerlink" title="提高效率的建议"></a>提高效率的建议</h4><ol><li><strong>传参时使用引用</strong>：避免拷贝对象的开销。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> MyClass&amp; obj)</span></span>; <span class="comment">// 使用引用，不调用拷贝构造函数</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>返回值优化（C++11 的移动语义）：</strong> 对于返回值尽量结合移动构造函数使用，减少不必要的拷贝。</li></ol><p><strong>综上：</strong></p><ul><li>拷贝构造函数是用已有对象初始化新对象的工具。</li><li>编译器默认的拷贝构造函数使用浅拷贝，只能处理简单类（没有动态资源）。</li><li>对于涉及动态资源的类，必须显式定义拷贝构造函数，确保深拷贝，避免内存泄漏或重复释放。</li></ul></blockquote><h3 id="4-2-默认拷贝构造函数"><a href="#4-2-默认拷贝构造函数" class="headerlink" title="4.2 默认拷贝构造函数"></a>4.2 默认拷贝构造函数</h3><p>编译器默认会生成一个浅拷贝版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    Date d2 = d1;  <span class="comment">// 调用默认拷贝构造函数</span></span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-自定义拷贝构造函数"><a href="#4-3-自定义拷贝构造函数" class="headerlink" title="4.3 自定义拷贝构造函数"></a>4.3 自定义拷贝构造函数</h3><p>当对象包含动态资源时，必须显式定义深拷贝逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Example</span>(<span class="type">const</span> Example&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        size = other.size;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = other.arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5. 赋值运算符重载"></a>5. 赋值运算符重载</h2><blockquote><p>C++ 中的 <strong>运算符重载</strong> 允许我们为类或对象定义新的运算符行为，使代码更直观和可读。</p><h2 id="5-1-对运算符重载关键点解释："><a href="#5-1-对运算符重载关键点解释：" class="headerlink" title="5.1 对运算符重载关键点解释："></a>5.1 对运算符重载关键点解释：</h2><h4 id="1-运算符重载的本质"><a href="#1-运算符重载的本质" class="headerlink" title="1. 运算符重载的本质"></a>1. 运算符重载的本质</h4><ul><li><p>运算符重载是通过定义一个特殊的函数，改变运算符对类对象的行为。</p></li><li><p><strong>函数名称：</strong> <code>operator</code> 后接具体运算符。例如：<code>operator+</code> 是用来重载加法运算符的函数。</p></li><li><p><strong>函数原型：</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;返回值类型 <span class="keyword">operator</span>操作符(参数列表);</span><br></pre></td></tr></table></figure><ul><li>例子：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj);</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-运算符重载规则"><a href="#2-运算符重载规则" class="headerlink" title="2. 运算符重载规则"></a>2. 运算符重载规则</h4><ul><li><strong>不能创建新的运算符：</strong> 只能重载已有运算符，不能重载不存在的符号（如 <code>operator@</code> 是非法的）。</li><li><strong>内置类型的运算符不能改变其含义：</strong> 例如整数相加（<code>3 + 5</code>）的行为不能被改变。</li><li><strong>某些运算符不能被重载：</strong> <code>.</code>, <code>.*</code>, <code>::</code>, <code>sizeof</code>, <code>?:</code> 不能被重载。</li><li><strong>至少有一个操作数是类类型：</strong> 不能对完全是内置类型的运算符重载，比如试图重载 <code>int + int</code>。</li></ul><h4 id="3-成员函数-vs-全局函数重载"><a href="#3-成员函数-vs-全局函数重载" class="headerlink" title="3. 成员函数 vs 全局函数重载"></a>3. 成员函数 vs 全局函数重载</h4><ul><li>运算符重载可以是类的 <strong>成员函数</strong> 或 <strong>全局函数</strong>。</li><li><strong>成员函数重载：</strong> 第一个操作数是当前对象，编译器会将操作数传递给隐藏的 <code>this</code> 指针。</li><li><strong>全局函数重载：</strong> 需要将两个操作数都作为参数传递。</li><li><strong>注意：赋值运算符重载（<code>operator=</code>）必须是成员函数，不能是全局函数。</strong></li></ul><h4 id="4-常见运算符重载的实现"><a href="#4-常见运算符重载的实现" class="headerlink" title="4. 常见运算符重载的实现"></a>4. 常见运算符重载的实现</h4><hr><h4 id="赋值运算符重载（operator-）"><a href="#赋值运算符重载（operator-）" class="headerlink" title="赋值运算符重载（operator=）"></a>赋值运算符重载（<code>operator=</code>）</h4><p><strong>特点：</strong></p><ol><li><strong>参数类型：</strong> <code>const T&amp;</code>，避免不必要的拷贝，传引用效率更高。</li><li><strong>返回值类型：</strong> <code>T&amp;</code>，返回对象的引用支持连续赋值（如 <code>a = b = c</code>）。</li><li><strong>检测自赋值：</strong> 检查是否给自己赋值（<code>if (this == &amp;obj)</code>）。</li></ol><ul><li>自赋值检查非常重要，因为如果不检查自赋值，可能会导致资源被错误释放或重复释放。例如，如果 <code>this == &amp;obj</code>，则 <code>delete data;</code> 会释放当前对象的资源，导致后续操作无法正确执行。</li></ul><ol start="4"><li><strong>返回 <code>*this</code>：</strong> 让赋值语句返回当前对象。</li></ol><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;obj) <span class="comment">// 检测是否自赋值</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span> data;    <span class="comment">// 释放已有资源</span></span><br><span class="line">         data = <span class="keyword">new</span> <span class="built_in">int</span>(*obj.data); <span class="comment">// 深拷贝，避免共享指针导致问题</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="前置-和-后置-重载"><a href="#前置-和-后置-重载" class="headerlink" title="前置++ 和 后置++ 重载"></a>前置++ 和 后置++ 重载</h4><ul><li><strong>前置++（<code>++obj</code>）：</strong> 返回增加后的值。</li><li><strong>后置++（<code>obj++</code>）：</strong> 返回增加前的旧值，调用时会多传一个 <code>int</code> 参数（编译器自动处理）。</li></ul><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 前置++，返回引用</span></span><br><span class="line"> MyClass&amp; <span class="keyword">operator</span>++()</span><br><span class="line"> &#123;</span><br><span class="line">     ++value; <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 后置++，返回值</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"> &#123;</span><br><span class="line">     MyClass temp = *<span class="keyword">this</span>; <span class="comment">// 保存当前对象</span></span><br><span class="line">     ++value;              <span class="comment">// 自增</span></span><br><span class="line">     <span class="keyword">return</span> temp;          <span class="comment">// 返回旧值</span></span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="加法运算符重载（operator-）"><a href="#加法运算符重载（operator-）" class="headerlink" title="加法运算符重载（operator+）"></a>加法运算符重载（<code>operator+</code>）</h4><p>加法运算符重载支持对象间的相加操作。</p><p><strong>实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重载加法运算符</span></span><br><span class="line"> MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; obj) <span class="type">const</span></span><br><span class="line"> &#123;</span><br><span class="line">     MyClass result;</span><br><span class="line">     result.value = <span class="keyword">this</span>-&gt;value + obj.value; <span class="comment">// 两个对象相加</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="5-默认运算符重载-vs-自定义实现"><a href="#5-默认运算符重载-vs-自定义实现" class="headerlink" title="5. 默认运算符重载 vs 自定义实现"></a>5. 默认运算符重载 vs 自定义实现</h4><p><strong>默认行为：</strong></p><ul><li>如果不显式实现赋值运算符（<code>operator=</code>）或拷贝构造函数（<code>operator=</code>），编译器会生成默认版本，逐字节拷贝。</li><li>默认行为对于 <strong>内置类型</strong>（如 <code>int</code>、<code>char</code>）完全适用。</li><li>对于 <strong>动态资源</strong>（如指针），默认行为可能导致 <strong>浅拷贝</strong> 问题（资源共享导致重复释放或悬空指针）。</li></ul><p><strong>是否需要自定义实现：</strong></p><ul><li>如果类中没有动态资源（如只包含内置类型或 STL 容器），默认生成的运算符重载就够用。</li><li>如果类中有动态资源（如指针），必须自定义运算符重载，确保深拷贝和正确释放资源。</li></ul><h4 id="6-为什么返回引用？"><a href="#6-为什么返回引用？" class="headerlink" title="6. 为什么返回引用？"></a>6. 为什么返回引用？</h4><ul><li><p>在运算符重载中，返回引用（<code>T&amp;</code>）有助于提高效率，并支持连续赋值操作（如 <code>a = b = c</code>）。</p></li><li><p>例如赋值运算符：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; obj)</span><br><span class="line">&gt;&#123;</span><br><span class="line">   <span class="comment">// 处理赋值逻辑</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>如果返回值而非引用，则每次赋值都会产生一个临时对象，效率低。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运算符重载让类对象可以像内置类型一样进行操作，提升了代码的可读性。但以下几点需要注意：</p><ol><li>只有已有的运算符可以被重载，且至少有一个操作数是类类型。</li><li>对于有动态资源的类，必须重载运算符以避免浅拷贝问题。</li><li>返回引用是为了支持连续赋值和提高效率。</li><li>某些运算符不能被重载，比如 <code>.</code>、<code>::</code>、<code>sizeof</code> 和 <code>?:</code>。</li></ol><p>通过合理设计运算符重载，可以让类使用起来更像内置类型，从而写出更加优雅和简洁的代码。</p></blockquote><blockquote><h2 id="5-2-示例："><a href="#5-2-示例：" class="headerlink" title="5.2 示例："></a>5.2 示例：</h2><h4 id="1-默认实现"><a href="#1-默认实现" class="headerlink" title="1. 默认实现"></a>1. 默认实现</h4><p>编译器默认按字节拷贝，可能造成资源冲突。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">31</span>)</span></span>;</span><br><span class="line">   d2 = d1;  <span class="comment">// 调用默认赋值运算符</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-1</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-重载赋值运算符"><a href="#2-重载赋值运算符" class="headerlink" title="2. 重载赋值运算符"></a>2. 重载赋值运算符</h4><p>当对象管理动态资源时，需要自定义赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Example</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Example</span>(<span class="type">int</span> size)</span><br><span class="line">   &#123;</span><br><span class="line">      arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">      <span class="keyword">this</span>-&gt;size = size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Example&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Example&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)<span class="comment">// 防止自赋值</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">delete</span>[] arr;</span><br><span class="line">          size = other.size;</span><br><span class="line">          arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              arr[i] = other.arr[i];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Example</span>() &#123; <span class="keyword">delete</span>[] arr; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span>* arr;</span><br><span class="line">   <span class="type">int</span> size;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载 +"></a>重载 <code>+</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   Date <span class="keyword">operator</span>+(<span class="type">int</span> days) &#123; <span class="keyword">return</span> <span class="built_in">Date</span>(year, month, day + days); &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; day &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">   Date d2 = d + <span class="number">5</span>;  <span class="comment">// 日期加5天</span></span><br><span class="line">   d<span class="number">2.</span><span class="built_in">Print</span>();  <span class="comment">// 输出：2025-1-6</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><h4 id="重载-1"><a href="#重载-1" class="headerlink" title="重载 =="></a>重载 <code>==</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&gt;&#123;</span><br><span class="line">&gt;<span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d) : <span class="built_in">year</span>(y), <span class="built_in">month</span>(m), <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Date&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> year == other.year &amp;&amp; month == other.month &amp;&amp; day == other.day;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> year, month, day;</span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="6-const-成员"><a href="#6-const-成员" class="headerlink" title="6. const 成员"></a>6. <code>const</code> 成员</h2><p>将 <code>const</code> 修饰的“<strong>成员函数</strong>”称之为 <code>const</code> 成员函数，<code>const</code> 成员函数修饰了隐含的 <code>this</code> 指针为 <code>const</code> 类型（<code>const ClassName* this</code>），表示该函数不能修改类的成员变量。但可以通过 <code>mutable</code> 修饰的成员变量在 <code>const</code> 成员函数中进行修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintConst</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Print(const)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;year:&quot;</span> &lt;&lt; _year &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;month:&quot;</span> &lt;&lt; _month &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;day:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;   <span class="comment">// 年</span></span><br><span class="line">    <span class="type">int</span> _month;  <span class="comment">// 月</span></span><br><span class="line">    <span class="type">int</span> _day;    <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> Date <span class="title">d2</span><span class="params">(<span class="number">2025</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    d<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐步理解上面代码：</p><ol><li>定义了两个 <code>Print</code> 函数：<ul><li><code>void Print()</code>：普通成员函数，允许修改对象。</li><li><code>void Print() const</code>：<code>const</code> 成员函数，不能修改对象。</li></ul></li><li><code>Test</code> 函数中：<ul><li><code>Date d1(2022, 1, 13);</code> 是普通对象，调用 <code>d1.Print()</code> 时，编译器会选择非 <code>const</code> 版本的 <code>Print()</code>。</li><li><code>const Date d2(2022, 1, 13);</code> 是 <code>const</code> 对象，调用 <code>d2.Print()</code> 时，编译器会选择 <code>const</code> 版本的 <code>Print()</code>。</li></ul></li></ol><h3 id="6-1-总结规则："><a href="#6-1-总结规则：" class="headerlink" title="6.1 总结规则："></a>6.1 总结规则：</h3><ol><li><strong>非 <code>const</code> 对象</strong>：<ul><li>可以调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 对象</strong>：<ul><li>只能调用 <code>const</code> 成员函数。</li></ul></li><li><strong>普通成员函数</strong>：<ul><li>可以调用普通成员函数。</li><li>不能调用 <code>const</code> 成员函数。</li></ul></li><li><strong><code>const</code> 成员函数</strong>：<ul><li>不能调用普通成员函数。</li><li>可以调用 <code>const</code> 成员函数。</li></ul></li></ol><hr><h3 id="6-2-适用场景："><a href="#6-2-适用场景：" class="headerlink" title="6.2 适用场景："></a>6.2 适用场景：</h3><ul><li>当你希望某个成员函数不修改对象的任何成员变量时，应将其声明为 <code>const</code> 成员函数。</li><li>这样可以确保该函数在 <code>const</code> 对象上调用时不会破坏对象的不可变性。</li><li>例如，<code>Print()</code> 函数通常不需要修改对象状态，因此可以声明为 <code>const</code> 成员函数。</li></ul><hr><h3 id="6-3-关键知识点："><a href="#6-3-关键知识点：" class="headerlink" title="6.3 关键知识点："></a>6.3 关键知识点：</h3><ul><li><strong><code>const</code> 修饰的成员函数</strong>：会将隐含的 <code>this</code> 指针转换为 <code>const</code> 类型（<code>const ClassName* this</code>）。</li><li>编译器通过 <code>const</code> 限定符，保证不会在 <code>const</code> 成员函数中修改成员变量。</li><li>如果非 <code>const</code> 成员变量必须在 <code>const</code> 成员函数中被修改，可以使用 <code>mutable</code> 关键字修饰这些变量，使其在 <code>const</code> 上下文中也可变（但要谨慎使用）。</li></ul><hr><blockquote><h2 id="传道解惑：-2"><a href="#传道解惑：-2" class="headerlink" title="传道解惑："></a>传道解惑：</h2><h3 id="Q1：-const-对象可以调用非-const-成员函数吗？"><a href="#Q1：-const-对象可以调用非-const-成员函数吗？" class="headerlink" title="Q1： const 对象可以调用非 const 成员函数吗？"></a>Q1： <code>const</code> 对象可以调用非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p><code>const</code> 对象意味着这个对象的任何成员都不能被修改。非 <code>const</code> 成员函数没有限制修改成员变量的行为，因此 <code>const</code> 对象无法调用非 <code>const</code> 成员函数，否则会破坏 <code>const</code> 对象的不变性。</p><p>在上面代码中，<code>const Date d2</code> 是一个 <code>const</code> 对象，只能调用 <code>Print(const)</code>，不能调用 <code>Print()</code>（非 <code>const</code> 成员函数）。编译器会通过检查 <code>const</code> 属性阻止这种调用。</p><hr><h3 id="Q2：const-对象可以调用-const-成员函数吗？"><a href="#Q2：const-对象可以调用-const-成员函数吗？" class="headerlink" title="Q2：const 对象可以调用 const 成员函数吗？"></a>Q2：<code>const</code> 对象可以调用 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数会修饰 <code>this</code> 指针为 <code>const Date* this</code>，表示该函数内部不会修改类的成员变量。因此 <code>const</code> 对象可以调用 <code>const</code> 成员函数，因为这不会破坏 <code>const</code> 对象的不可变性。</p><p>在上面代码中，<code>d2.Print()</code> 调用的就是 <code>Print(const)</code>，因为 <code>Print(const)</code> 是 <code>const</code> 成员函数。</p><hr><h3 id="Q3：const-成员函数内可以调用其它的非-const-成员函数吗？"><a href="#Q3：const-成员函数内可以调用其它的非-const-成员函数吗？" class="headerlink" title="Q3：const 成员函数内可以调用其它的非 const 成员函数吗？"></a>Q3：<code>const</code> 成员函数内可以调用其它的非 <code>const</code> 成员函数吗？</h3><p><strong>不可以</strong>。</p><p>因为 <code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，即 <code>const Date* this</code>，表示它不能修改成员变量。而非 <code>const</code> 成员函数默认的 <code>this</code> 指针是 <code>Date* this</code>，允许修改成员变量。<br>因此，<code>const</code> 成员函数无法调用非 <code>const</code> 成员函数，因为这样可能导致间接修改成员变量，从而违反了 <code>const</code> 的约束。</p><hr><h3 id="Q4-const-成员函数内可以调用其它的-const-成员函数吗？"><a href="#Q4-const-成员函数内可以调用其它的-const-成员函数吗？" class="headerlink" title="Q4: const 成员函数内可以调用其它的 const 成员函数吗？"></a>Q4: <code>const</code> 成员函数内可以调用其它的 <code>const</code> 成员函数吗？</h3><p><strong>可以</strong>。</p><p><code>const</code> 成员函数的 <code>this</code> 指针是 <code>const</code> 的，调用其他 <code>const</code> 成员函数不会违反 <code>const</code> 的约束，因为 <code>const</code> 成员函数保证不修改成员变量。</p></blockquote><h2 id="7-取地址及-const-取地址操作符重载"><a href="#7-取地址及-const-取地址操作符重载" class="headerlink" title="7. 取地址及 const 取地址操作符重载"></a>7. 取地址及 <code>const</code> 取地址操作符重载</h2><p>在 C++中，取地址操作符 <code>&amp;</code> 不能被真正重载。但可以通过定义特殊的成员函数来改变其行为。这种实现方式类似于运算符重载，但并非真正的重载。结合 <code>const</code>，它的行为会更有针对性。（取地址操作符 <code>&amp;</code> 不能被重载的原因是，它是一个基础操作符，用于获取对象的地址。如果允许重载，可能会导致地址获取的语义混乱。）</p><h3 id="7-1-取地址操作符-默认行为"><a href="#7-1-取地址操作符-默认行为" class="headerlink" title="7.1 取地址操作符 &amp; 默认行为"></a>7.1 取地址操作符 <code>&amp;</code> 默认行为</h3><p>默认情况下，<code>&amp;</code> 操作符返回对象的内存地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* px = &amp;x; <span class="comment">// px 获取了 x 的地址</span></span><br></pre></td></tr></table></figure><p>在类中，取地址操作符通常也可以被用来获取对象的地址。</p><h3 id="7-2-取地址操作符的重载"><a href="#7-2-取地址操作符的重载" class="headerlink" title="7.2 取地址操作符的重载"></a>7.2 取地址操作符的重载</h3><p>C++中无法重载取地址操作符 <code>&amp;</code>，但可以通过定义成员函数来改变其行为。例如通过返回自定义指针对象，而不是直接返回 <code>this</code>。重载时可以区分：</p><ol><li>普通对象的取地址。</li><li><code>const</code> 对象的取地址。</li></ol><h3 id="7-3-代码示例与解释"><a href="#7-3-代码示例与解释" class="headerlink" title="7.3 代码示例与解释"></a>7.3 代码示例与解释</h3><p>重载取地址操作符的代码，以下是一个简单示例，展示如何通过 <code>const</code> 和非 <code>const</code> 版本的重载来实现不同的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : _value(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非 const 版本的取地址操作符重载</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;非 const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const 版本的取地址操作符重载</span></span><br><span class="line">    <span class="type">const</span> MyClass* <span class="keyword">operator</span>&amp;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const 取地址操作符被调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; _value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;            <span class="comment">// 普通对象</span></span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// const 对象</span></span><br><span class="line"></span><br><span class="line">    MyClass* addr1 = &amp;obj;          <span class="comment">// 调用非 const 版本的取地址操作符</span></span><br><span class="line">    <span class="type">const</span> MyClass* addr2 = &amp;constObj; <span class="comment">// 调用 const 版本的取地址操作符</span></span><br><span class="line"></span><br><span class="line">    addr1-&gt;<span class="built_in">Display</span>();</span><br><span class="line">    addr2-&gt;<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">非 const 取地址操作符被调用</span><br><span class="line">const 取地址操作符被调用</span><br><span class="line">Value: 10</span><br><span class="line">Value: 20</span><br></pre></td></tr></table></figure><p><strong>代码解释</strong></p><ol><li><strong>普通对象调用非 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对普通对象 <code>obj</code> 使用 <code>&amp;</code> 时，调用的是 <code>MyClass* operator&amp;()</code>。</li><li>返回类型是一个非 <code>const</code> 指针，即 <code>MyClass*</code>。</li><li>这意味着我们可以通过这个指针修改 <code>obj</code>。</li></ul></li><li><strong><code>const</code> 对象调用 <code>const</code> 版本的取地址操作符</strong>：<ul><li>当我们对 <code>const</code> 对象 <code>constObj</code> 使用 <code>&amp;</code> 时，调用的是 <code>const MyClass* operator&amp;() const</code>。</li><li>返回类型是 <code>const MyClass*</code>，即一个不可修改的指针。</li><li>这保证了通过返回的地址无法修改 <code>constObj</code>。</li></ul></li></ol><blockquote><h2 id="传道解惑"><a href="#传道解惑" class="headerlink" title="传道解惑"></a>传道解惑</h2><h3 id="Q1：两种版本为什么重要？"><a href="#Q1：两种版本为什么重要？" class="headerlink" title="Q1：两种版本为什么重要？"></a>Q1：两种版本为什么重要？</h3><ul><li>如果只有普通的非 <code>const</code> 重载（<code>MyClass* operator&amp;()</code>），<code>const</code> 对象调用时会报错，因为无法确保 <code>const</code> 对象的不可变性。</li><li>如果只有 <code>const</code> 版本重载（<code>const MyClass* operator&amp;() const</code>），普通对象也只能得到一个 <code>const</code> 指针，限制了可操作性。</li></ul><p>因此，同时提供两个版本：</p><ul><li>普通对象取地址时返回普通指针，灵活操作。</li><li><code>const</code> 对象取地址时返回 <code>const</code> 指针，保护不可变性。</li></ul><hr><h3 id="Q2：取地址操作符重载的应用场景？"><a href="#Q2：取地址操作符重载的应用场景？" class="headerlink" title="Q2：取地址操作符重载的应用场景？"></a>Q2：取地址操作符重载的应用场景？</h3><ol><li><strong>调试日志</strong>：可以在取地址时打印出信息，便于调试。</li><li><strong>对象管理</strong>：可以控制对象暴露出去的指针，避免外部直接操作原始地址。</li><li><strong>定制行为</strong>：对于特定的类，可以在取地址时返回自定义指针对象，而不是直接返回 <code>this</code>。</li></ol><hr><h3 id="Q3：为什么需要区分-const-对象的取地址？"><a href="#Q3：为什么需要区分-const-对象的取地址？" class="headerlink" title="Q3：为什么需要区分 const 对象的取地址？"></a>Q3：为什么需要区分 <code>const</code> 对象的取地址？</h3><p>假如我们不区分 <code>const</code> 和非 <code>const</code> 对象取地址操作，就会产生如下问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="type">const</span> MyClass <span class="title">constObj</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&gt;MyClass* ptr = &amp;constObj; <span class="comment">// 如果没有 const 重载，这会破坏 constObj 的不可变性</span></span><br></pre></td></tr></table></figure><p>通过引入 <code>const</code> 版本的取地址操作符重载，编译器可以在 <code>const</code> 对象中强制返回 <code>const</code> 指针，保护数据安全。</p><ol><li>取地址操作符重载的作用：</li></ol><ul><li>自定义取地址操作符的行为。</li><li>区分普通对象和 <code>const</code> 对象的地址获取方式。</li></ul><ol start="2"><li>注意事项：</li></ol><ul><li>对普通对象，返回普通指针。</li><li>对 <code>const</code> 对象，返回 <code>const</code> 指针，确保不可变性。</li></ul><p>这是一种增强代码灵活性与安全性的手段，同时对复杂场景（如调试或资源管理）非常有用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象（上）</title>
      <link href="/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2025/04/01/02%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、本节目标"><a href="#一、本节目标" class="headerlink" title="一、本节目标"></a>一、<strong>本节目标</strong></h2><ol><li><strong>面向过程和面向对象初步认识</strong></li><li><strong>类的引入</strong></li><li><strong>类的定义</strong></li><li><strong>类的访问限定符及封装</strong></li><li><strong>类的作用域</strong></li><li><strong>类的实例化</strong></li><li><strong>类的对象大小的计算</strong></li><li><strong>类成员函数的 <code>this</code> 指针</strong></li></ol><h2 id="二、面向过程和面向对象初步认识（过程与面向对象编程）"><a href="#二、面向过程和面向对象初步认识（过程与面向对象编程）" class="headerlink" title="二、面向过程和面向对象初步认识（过程与面向对象编程）"></a>二、面向过程和面向对象初步认识（过程与面向对象编程）</h2><p><strong>面向过程编程（ProceduralProgramming）</strong>：</p><ul><li>关注“<strong>过程</strong>”或“步骤”。</li><li>将问题分解为函数，每个函数执行一个特定的任务。</li><li>主要依赖函数调用，常见于 C 语言。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向过程编程: 通过函数处理数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Processing data: %d\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面向对象编程（Object-OrientedProgramming）</strong>：</p><ul><li>关注“<strong>对象</strong>”，将数据与操作数据的方法结合。</li><li>通过对象之间的交互解决问题，常见于 C++。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Processor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Processing data: &quot;</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Processor p;</span><br><span class="line">    p.<span class="built_in">process</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>C 语言是 <strong>面向过程</strong> 的，<strong>关注</strong> 的是 <strong>过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。</li><li>C++是 <strong>基于面向对象</strong> 的，<strong>关注</strong> 的是 <strong>对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</li></ul><h2 id="三、类的引入（Introduction-to-Classes）"><a href="#三、类的引入（Introduction-to-Classes）" class="headerlink" title="三、类的引入（Introduction to Classes）"></a>三、类的引入（Introduction to Classes）</h2><p><strong>C 语言结构体中只能定义变量，在 C++中，结构体内不仅可以定义变量，也可以定义函数。</strong> 例如： 之前在数据结构初阶中，用 <strong>C 语言方式实现的栈，结构体中只能定义变量</strong>；但在 C++中，<code>struct</code> 和 <code>class</code> 都可以包含 <strong>变量</strong> 和 <strong>函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// for malloc and free</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">    DataType* array;</span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">size_t</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array = (DataType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DataType) * cap);</span><br><span class="line">        <span class="keyword">if</span> (!array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        capacity = cap;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压栈操作</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> DataType&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array[size++] = data; <span class="comment">// 简化的例子，未考虑扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取栈顶元素</span></span><br><span class="line">    <span class="function">DataType <span class="title">Top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(array);</span><br><span class="line">            array = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    s.<span class="built_in">Init</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">Push</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Top element: &quot;</span> &lt;&lt; s.<span class="built_in">Top</span>() &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">Destroy</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面结构体的定义，<strong>在 C++中更喜欢用 <code>class</code> 来代替</strong>。</p><h2 id="四、类的定义（Defining-a-Class）"><a href="#四、类的定义（Defining-a-Class）" class="headerlink" title="四、类的定义（Defining a Class）"></a>四、类的定义（Defining a Class）</h2><p><strong>类的定义</strong>：<code>class</code> 是定义类的关键字。类是对象的蓝图，包含成员变量（属性）和成员函数（方法）。</p><ul><li><strong>类定义语法</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>为定义类的关键字，ClassName为类的名字，&#123;&#125;中为类的主体，</span><br><span class="line">注意类定义结束时后面分号不能省略。</span><br><span class="line"> </span><br><span class="line">类体中内容称为类的成员：类中的变量称为类的属性或成员变量; </span><br><span class="line">类中的函数称为类的方法或者成员函数。</span><br></pre></td></tr></table></figure><p><strong>两种定义方式</strong>：</p><ol><li><strong>在类体中定义成员函数</strong>：这样的函数可能被编译器视为 <code>inline</code> 内联函数。</li><li><strong>类声明与定义分离</strong>：通常将类的声明放在 <code>.h</code> 文件中，成员函数的定义放在 <code>.cpp</code> 文件中。注意：<strong>成员函数名前需要加类名::</strong></li></ol><p><strong>示例 1：类体中定义所有内容</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 2：类声明与定义分离</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Date.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Date.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Date.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _year = year;</span><br><span class="line">    _month = month;</span><br><span class="line">    _day = day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Date::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）"><a href="#五、类的访问限定符及封装（Access-Specifiers-and-Encapsulation）" class="headerlink" title="五、类的访问限定符及封装（Access Specifiers and Encapsulation）"></a>五、类的访问限定符及封装（Access Specifiers and Encapsulation）</h2><p><strong>访问限定符</strong> 用于控制类的成员是否能够在类外部访问：</p><ul><li><code>public</code>：类外可以访问。</li><li><code>private</code>：类外部不能直接访问，只能通过类的内部方法操作。</li><li><code>protected</code>：类外部无法访问，但在继承中可以访问。</li></ul><p><strong>封装（Encapsulation）</strong>：隐藏类的实现细节，仅对外提供公共接口，保证数据的安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year, _month, _day;  <span class="comment">// 这些变量无法在类外直接访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date today;</span><br><span class="line">    today.<span class="built_in">Init</span>(<span class="number">2024</span>, <span class="number">9</span>, <span class="number">22</span>);</span><br><span class="line">    today.<span class="built_in">Print</span>();  <span class="comment">// 只能通过Print()访问日期信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、类的作用域（Class-Scope）"><a href="#六、类的作用域（Class-Scope）" class="headerlink" title="六、类的作用域（Class Scope）"></a>六、类的作用域（Class Scope）</h2><p>类的成员定义在类的作用域内，在类外部使用成员函数时，必须用域操作 <code>::</code> 指定该成员属于哪个作用类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::SetName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(_name, name);  <span class="comment">// 设置名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; _name &lt;&lt; endl;  <span class="comment">// 打印名字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">SetName</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    p.<span class="built_in">PrintName</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、类的实例化（Instantiation-of-Classes）"><a href="#七、类的实例化（Instantiation-of-Classes）" class="headerlink" title="七、类的实例化（Instantiation of Classes）"></a>七、类的实例化（Instantiation of Classes）</h2><p>类的 <strong>实例化</strong> 是指 <strong>通过类的定义创建对象</strong>，分配实际的内存空间给成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetBrand</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* brand)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(_brand, brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Car brand: &quot;</span> &lt;&lt; _brand &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _brand[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Car car1, car2;  <span class="comment">// 实例化两个对象</span></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Toyota&quot;</span>);</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">SetBrand</span>(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line"></span><br><span class="line">    car<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    car<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>类是对对象进行描述的</strong>，是一个 <strong>模型</strong> 一样的东西，限定了类有哪些成员，定义出一个类 <strong>并没有分配实际的内存空间</strong> 来存储它；比如：入学时填写的学生信息表，表格就可以看成是一个类，来描述具体学生信息。</li></ol><p>​类就像谜语一样，对谜底来进行描述，谜底就是谜语的一个实例。</p><p>​谜语：”年纪不大，胡子一把，主人来了，就喊妈妈” 谜底：山羊</p><ol start="2"><li>一个类可以实例化出多个对象，<strong>实例化出的对象 占用实际的物理空间，存储类成员变量</strong></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     Person._age = <span class="number">100</span>;   <span class="comment">// 编译失败：error C2059: 语法错误:“.”</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person类是没有空间的，只有Person类实例化出的对象才有具体的年龄。</span><br></pre></td></tr></table></figure><ol start="3"><li>做个比方。<strong>类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</strong>，只设计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象才能实际存储数据，占用物理空间</li></ol><h2 id="八、类对象模型（Class-Object-Model）"><a href="#八、类对象模型（Class-Object-Model）" class="headerlink" title="八、类对象模型（Class Object Model）"></a>八、类对象模型（Class Object Model）</h2><p><strong>类对象的大小</strong> 由成员变量的大小决定，成员函数的代码不会占用对象的存储空间。</p><ul><li><strong>空类</strong> 的大小为 1 字节，确保每个对象都有唯一标识。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">char</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of Empty class: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Empty) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of A: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;  <span class="comment">// 由于内存对齐的影响，可能比预期的更大</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论：一个类的大小，实际就是该类中”成员变量”之和，当然要注意内存对齐。注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。</strong></p><h3 id="结构体内存对齐规则（Struct-Memory-Alignment-Rules）"><a href="#结构体内存对齐规则（Struct-Memory-Alignment-Rules）" class="headerlink" title="结构体内存对齐规则（Struct Memory Alignment Rules）"></a>结构体内存对齐规则（Struct Memory Alignment Rules）</h3><p><strong>内容对齐</strong> 的规则(<a href="https://blog.csdn.net/Huangcancan666/article/details/140896458?spm=1001.2014.3001.5501">【C 语言】结构体内存布局解析——字节对齐_字节对齐规则-CSDN 博客</a>)：</p><ol><li>第一个成员从偏移量为 0 的位置开始。</li><li>其他成员遵循它们大小的整数倍对齐。</li><li>总大小为最大对齐数的整数倍。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S1</span> &#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S2</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S1) &lt;&lt; endl;  <span class="comment">// 8字节，内存对齐使得char占4字节</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of S2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(S2) &lt;&lt; endl;  <span class="comment">// 8字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、this-指针"><a href="#九、this-指针" class="headerlink" title="九、this 指针"></a>九、this 指针</h2><p>在 C++中，<code>this</code> 指针是一个特殊的指针，用于指向调用成员函数的当前对象（当前对象）。它只在类的非静态成员函数下面可用，是传递方式的。是对 <code>this</code> 指针隐式的详细讲解，包括特性、与 C 语言的对比，以及常见的易错点。</p><h3 id="1-引出：什么是-this-指针？"><a href="#1-引出：什么是-this-指针？" class="headerlink" title="1. 引出：什么是 this 指针？"></a>1. 引出：什么是 <code>this</code> 指针？</h3><p>当一个对象调用其类的非静态成员函数时，编译器会自动传递该对象的地址给函数。<code>this</code> 指针就是该对象的地址的成员函数。它可以用于在成员函数中调用该函数的对象的地址成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;  <span class="comment">// 使用this指针，避免成员变量与参数重名冲突</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-特性："><a href="#2-特性：" class="headerlink" title="2. 特性："></a>2. 特性：</h3><ul><li><p><strong>隐式传递</strong>：<code>this</code> 指针不需要显式声明，它在所有非静态成员函数中隐式可用。</p></li><li><p><strong>常量性</strong>：<code>this</code> 指针是常量指针，无法修改其指向的对象。即 <code>this</code> 类型为 <code>MyClass* const</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>指向当前对象</strong>：<code>this</code> 指向调用该成员函数的当前对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">func</span>();  <span class="comment">// this指针指向obj</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在常量成员函数中的 <code>this</code> 指针</strong>：在常量成员函数中，<code>this</code> 指针是指向常量的指针，其类型为 <code>const MyClass* const</code>，表示不能 <code>this</code> 修改对象的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误！无法修改常成员函数中的对象数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-与-C-的对比："><a href="#3-与-C-的对比：" class="headerlink" title="3. 与 C 的对比："></a>3. 与 C 的对比：</h3><p>C 语言本身不支持类和对象的概念，因此也不存在 <code>this</code> 指针。在 C 中，要模拟类似的行为，通常需要显式传递结构体指针来访问结构体的成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C++中的<span class="keyword">this</span>指针对应于在C语言中手动传递对象指针给函数的做法：</span><br><span class="line"><span class="comment">// C语言模拟对象方法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">struct</span> MyClass* self, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    self-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line">在C++中，这种显着式的传递结构指针的方式通过<span class="keyword">this</span>指针抓取方式和自动化，简化了编程。</span><br></pre></td></tr></table></figure><h3 id="4-常见易错点："><a href="#4-常见易错点：" class="headerlink" title="4. 常见易错点："></a>4. 常见易错点：</h3><ul><li><p><strong>修改 <code>this</code> 指针</strong>：<code>this</code> 是常量指针，不能修改其指向对象，错误的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this = nullptr; // 错误！无法修改this指针的指向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在静态成员函数中使用 <code>this</code></strong>：静态成员函数属于类本身，而不是某个特定对象，因此，静态成员函数中没有 <code>this</code> 指针。如果尝试在静态成员函数中使用 <code>this</code>，会出现编译错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// this-&gt;value = 10;  // 错误，静态成员函数没有this指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回 <code>*this</code></strong>：在链式调用时，经常会返回当前对象的引用，返回 <code>*this</code> 是合法的用法。常见的用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回当前对象的引用，支持链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在构造函数或解析构造函数中使用 <code>this</code></strong>：在构造函数中使用 <code>this</code> 指针是安全的，但需要注意不要在构造函数中将 <code>this</code> 指针导出出去（比如在构造函数中调用虚函数）。在构造函数中，<code>this</code> 指向即将被关注的对象，因此要小心避免对已关注的资源操作。</p></li></ul><h3 id="5-小结："><a href="#5-小结：" class="headerlink" title="5. 小结："></a>5. 小结：</h3><ul><li><code>this</code> 指针用于指向当前对象，并在非静态成员函数中隐式传递。</li><li>它是一个常量指针，不能修改指向的对象。</li><li>静态成员函数中没有 <code>this</code> 指针。</li><li><code>this</code> 在 C++中简化了对象成员的访问，而在 C 语言中，需要手动传递结构体指针。</li></ul><p>掌握 <code>this</code> 指针有助于理解对象成员的访问方式和 C++类的工作原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了对象编程中的类、对象、封装、作用域、实例化、对象模型、内存定位和 <code>this</code> 指针的详细内容和代码示例。你可以通过编写这些代码加深理解，并尝试修改运行和它们来更好地掌握这些概念。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obsidian使用</title>
      <link href="/2023/09/01/obsidian%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/09/01/obsidian%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在 Obsidian 最新版中，正反向链接、标签和属性是核心功能，用于构建知识网络、分类管理及添加</p><h3 id="一、正反向链接"><a href="#一、正反向链接" class="headerlink" title="一、正反向链接"></a><strong>一、正反向链接</strong></h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>正向链接（出链）</strong>：当前笔记中主动引用其他笔记或段落。</li><li><strong>反向链接（入链）</strong>：其他笔记引用当前笔记时自动生成的反向关联。</li><li><strong>作用</strong>：形成双向知识网络，通过链接关系追溯相关内容。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[目标笔记名]]                  # 链接到整篇笔记</span><br><span class="line">[[目标笔记名#标题]]             # 链接到特定标题</span><br><span class="line">[[目标笔记名#^段落ID]]          # 链接到具体段落（块）</span><br><span class="line">[[目标笔记名|别名]]             # 使用别名显示链接</span><br></pre></td></tr></table></figure></li><li><p><strong>操作提示</strong>：  </p><ul><li>输入 <code>[[</code> 后，Obsidian 会自动提示可链接的笔记。</li><li>支持嵌入内容（如图片、视频）：<code>![[图片名.png]]</code>。</li><li>段落块 ID 可通过光标悬停段落时点击「复制块链接」获取。</li></ul></li><li><p><strong>查看反向链接</strong>：<br> 在右侧面板或笔记底部查看「反向链接」，显示所有引用当前笔记的位置。</p></li></ol><hr><h3 id="二、标签"><a href="#二、标签" class="headerlink" title="二、标签"></a><strong>二、标签</strong></h3><h4 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>分类管理</strong>：通过 <code>#标签</code> 对笔记进行主题或属性标记。</li><li><strong>嵌套标签</strong>：支持层级结构（如 <code>#科研/论文</code>），实现精细分类。</li><li><strong>作用</strong>：快速检索、批量管理相关笔记。</li></ul><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：  </p> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#标签名         # 普通标签</span></span><br><span class="line"><span class="section">#父标签/子标签  # 嵌套标签</span></span><br></pre></td></tr></table></figure></li><li><p><strong>优化实践</strong>：  </p><ul><li><p>将标签置于 YAML front matter 中，避免正文干扰：  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">Obsidian</span>, <span class="string">教程</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>Tag Wrangler 插件</strong>：  </p><ul><li>右键标签批量重命名、创建标签页、拖拽插入标签。</li><li>管理嵌套标签结构，生成标签树。</li></ul></li></ul></li></ol><hr><h3 id="三、属性（YAML-Front-Matter）"><a href="#三、属性（YAML-Front-Matter）" class="headerlink" title="三、属性（YAML Front Matter）"></a><strong>三、属性（YAML Front Matter）</strong></h3><h4 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a><strong>功能</strong></h4><ul><li><strong>元数据管理</strong>：为笔记添加结构化信息（如作者、创建时间、进度等）。</li><li><strong>类型支持</strong>：文本、列表、数字、日期等（需手动定义类型）。</li><li><strong>作用</strong>：配合插件（如 Dataview）实现高级查询和自动化管理。</li></ul><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><ol><li><p><strong>基础语法</strong>：<br> 在笔记开头添加 YAML 块：  </p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">aliases:</span> [<span class="string">别名1</span>, <span class="string">别名2</span>]  <span class="comment"># 别名</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">标签名</span>             <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-01</span>        <span class="comment"># 日期类型属性</span></span><br><span class="line"><span class="attr">progress:</span> <span class="string">进行中</span>         <span class="comment"># 文本类型属性</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p><strong>类型定义</strong>：  </p><ul><li>属性值默认文本类型，可通过插件或手动标注类型（如 <code>date:: 2023-09-01</code>）。</li></ul></li><li><p><strong>模板自动化</strong>：  </p><ul><li>结合模板插件，自动插入常用属性（如 <code>&#123;&#123;date&#125;&#125;</code> 生成当前日期）。</li></ul></li></ol><hr><h3 id="版本注意事项"><a href="#版本注意事项" class="headerlink" title="版本注意事项"></a><strong>版本注意事项</strong></h3><ul><li><strong>桌面端</strong>：1.4.5+ 支持完整属性功能。</li><li><strong>移动端</strong>：暂不支持属性（截至 2023.09），建议通过桌面端编辑。</li></ul><hr><h3 id="总结：使用场景"><a href="#总结：使用场景" class="headerlink" title="总结：使用场景"></a><strong>总结：使用场景</strong></h3><ol><li><strong>正反向链接</strong>：构建知识关联，推荐用于概念解释、参考文献。</li><li><strong>标签</strong>：快速分类，适合主题标记（如 <code>#待办</code>、<code>#灵感</code>）。</li><li><strong>属性</strong>：结构化元数据，适用于项目管理（如 <code>status: 进行中</code>）。</li></ol><p>通过组合这些功能，Obsidian 可实现高效的知识管理与深度关联。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记/工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Obsidian </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
